theory Sealing
begin

builtins: symmetric-encryption

functions: shared_key/1 [private], sealing_key/1 [private], MAC/2

////////////////////////////////////////////////////////////////////////
//////////////////////////////  Sealing  //////////////////////////////
////////////////////////////////////////////////////////////////////////

rule Client_1_S [color=#add8e6]:
	let
		sk = shared_key($sk1)
		m = senc(<~k, ~nonce>, sk)
	in
	[
		Fr(~k),
		Fr(~nonce),
		Fr(~tid)
	]--[
		Client_1_S_O(m),
		AliceKey(~tid, ~k)
	]->[
		AState(~tid, ~k, ~nonce),
		Out(m)
	]

rule Client_2_S [color=#add8e6]:
	let
		mk = shared_key($mk1)
		sk = shared_key($sk1)
	in
	[
		AState(~tid, ~k, ~nonce),
		In(<sealed_data, MAC(<sealed_data, ~nonce>, mk)>)
	]--[
		Sealed(~tid, mk, sk),
		// Eq(mac, MAC(<sealed_data, ~nonce>, mk)),
		Done1(),
		Secret(~k)
	]->[
		Out(sealed_data) // send to network instead of saving to disk
	]

rule Server_S [color=#d3d3d3]:
	let
		sk = shared_key($sk1)
		mk = shared_key($mk1)
		self_key = sealing_key($server)
		sealed_data = senc(<$server, ~k>, self_key)
		// REVIEW remove $server from sealed data since key already bound to it?
		m = senc(<~k, ~nonce>, sk)
	in
	[
		In(m)
	]--[
		Server_S_I(~k, m),
		N1(~nonce),
		Secret(~k)
	]->[
		Out(<sealed_data, MAC(<sealed_data, ~nonce>, mk)>)
	]

////////////////////////////////////////////////////////////////////////
/////////////////////////////  Unsealing  /////////////////////////////
////////////////////////////////////////////////////////////////////////

rule Client_1_U [color=#ffb6c1]:
	let
		mk = shared_key($mk2)
	in
	[
		In(sealed_data), // receive from network instead of loading from disk
		// Fr(~sealed_data),
		Fr(~nonce),
		Fr(~tid)
	]--[
	]->[
		BState(~tid, ~nonce),
		Out(<sealed_data, ~nonce, MAC(<sealed_data, ~nonce>, mk)>)
	]

rule Client_2_U [color=#ffb6c1]:
	let
		mk = shared_key($mk2)
		sk = shared_key($sk2)
	in
	[
		BState(~tid, ~nonce),
		// In(<sealed_data, mac>)
		In(senc(<~k, ~nonce>, sk))
	]--[
		Client_2_U_I(~k, senc(<~k, ~nonce>, sk)),
		Unsealed(~tid, mk, sk),
		BorisKey(~tid, ~k),
		// Neq($sk1, $sk2),
		// Neq($mk1, $mk2),
		// Neq($sk1, $mk1),
		// Neq($sk2, $mk2),

		Done2(),
		Secret(~k)
	]->[
	]

rule Server_U [color=#d3d3d3]:
	let
		mk = shared_key($mk2)
		//2 computed_mac = MAC(<sealed_data, nonce>, mk)
		self_key = sealing_key($server)
		//2 k = sdec(sealed_data, self_key)
		// k = sdec(sealed_data, sealing_key($server))
		sk = shared_key($sk2)

		sealed_data = senc(<$server, ~k>, self_key)
	in
	[
		//2 In(<sealed_data, nonce, received_mac>)
		In(<sealed_data, ~nonce, MAC(<sealed_data, ~nonce>, mk)>)
	]--[
		N2(~nonce),
		Server_U_O(senc(<~k, ~nonce>, sk)),
		//2 Eq(received_mac, computed_mac),
		Secret(~k)
	]->[
		Out(senc(<~k, ~nonce>, sk))
	]

////////////////////////////////////////////////////////////////////////
/////////////////////////////  Properties  /////////////////////////////
////////////////////////////////////////////////////////////////////////

// restriction Equality:
// 	"All x y #i. Eq(x,y)@i ==> x=y"

// restriction Inequality:
// 	"All x #i. Neq(x,x) @ #i ==> F"

restriction foo:
	"All n1 n2 #i #j. N1(n1) @ #i & N2(n2) @ #j ==> not(n1=n2)"

lemma loop [sources]:
	"(All k m #i.
		Server_S_I(k, m) @ #i ==> (
			(Ex #j. KU(k) @ #j & j < i) | (Ex #j. Client_1_S_O(m) @ #j)
		)
	) &
	(All k m #i.
		Client_2_U_I(k, m) @ #i ==> (
			(Ex #j. KU(k) @ #j & j < i) | (Ex #j. Server_U_O(m) @ #j)
		)
	)"

// TODO restringir single ~k para evitar split dig?
// FIXME Client-2-S ignorado, mesmo in out?

lemma secrecy:
	"All k #i #j. Secret(k) @i & K(k) @j ==> F"

lemma functional: exists-trace
	"Ex #i #j. Done1() @ #i & Done2() @ #j"

lemma executable: exists-trace
	"Ex
		key
		tid_Alice mk1 sk1
		tid_Boris mk2 sk2
	#i #j #x #y.
	Sealed(tid_Alice, mk1, sk1) @ #i &
	Unsealed(tid_Boris, mk2, sk2) @ #j &
	AliceKey(tid_Alice, key) @ #x &
	BorisKey(tid_Boris, key) @ #y"

end
