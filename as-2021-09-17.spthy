/**
** Protocol: AS v3
** Author:   Daniel Andrade
** Date:     03/2021
** Status:   WIP
**/

theory ASv3
begin

builtins: hashing, signing, diffie-hellman
builtins: asymmetric-encryption, symmetric-encryption

functions:
	CMAC/2,                  // RFC 4493
	SHA/1,
	transport_key/3 [private], // source, destination, session nonce // rat
	//isk/0 [private],         // Intel Signing Key
	//rsk/0 [private],         // Report Signing Key
	real/1 [private],
	sgx_get_key/1
	//sgx_get_key/1 [private]  //TODO Why this doesn't work?

rule Create_IAS:
	[
		Fr(~id_IAS),
		Fr(~priv_IAS)
	]--[
		OnlyOnce(),
		Create_IAS(~id_IAS)
	]->[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS), // root keys, we use single key pair
		Out(~id_IAS)
	]

rule Create_CAS:
	[ Fr(~id_CAS) ]--[ Create_CAS(~id_CAS) ]->[ !ID_CAS(~id_CAS), Out(~id_CAS) ]

rule Create_RAS:
	[ Fr(~id_RAS) ]--[ Create_RAS(~id_RAS) ]->[ !ID_RAS(~id_RAS), Out(~id_RAS) ]

rule Create_QE:
	[ Fr(~id_QE) ]--[ Create_QE(~id_QE) ]->[ !ID_QE(~id_QE), Out(~id_QE) ]

rule Create_Enclave:
	[
		Fr(~id_Enclave),
		Fr(~MRENCLAVE),
		Fr(~MRSIGNER)
	]--[
		Create_Enclave(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]->[
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		Out(~id_Enclave),
		Out(~MRENCLAVE),
		Out(~MRSIGNER)
	]

rule Create_CPU:
	[
		Fr(~id_CPU)
	]--[
		Create_CPU(~id_CPU)
	]->[
		!ID_CPU(~id_CPU),
		Out(~id_CPU)
	]

// Provision CPU and QE: essentially registers these two agents with Intel
rule Provisioning:
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		!ID_QE(~id_QE),
		!ID_CPU(~id_CPU),
		Fr(~tid_QE),
		Fr(~priv_QE), // attestation key for QE, uses to sign quotes
		Fr(~tid_CPU)
	]--[
		Provision(~id_QE, ~id_CPU, ~id_IAS, ~tid_QE, ~tid_CPU)
	]->[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		State_CPU(~tid_CPU, 'Provisioning_CPU', <~id_CPU, ~tid_QE, ~id_QE, ~id_IAS, sign(~id_CPU, ~priv_IAS), pk(~priv_IAS)>)
	]

// Whitelist enclave
rule Licensing:
	let
		// Enclave ID, IAS ID, IAS signature over Enclave ID, IAS public key
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]--[
		Licensing(~id_Enclave, ~id_IAS)
	]->[
		!License(~id_Enclave, license)
	]

// Bind enclave to CPU
// FIXME: Enclave deve ter lá os MR ?? TODO: acho que sim para poder fork igual
rule Binding:
	[
		!ID_CPU(~id_CPU),
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		Fr(~tid_Enclave)
	]--[
		Binding(~tid_Enclave, ~id_Enclave, ~id_CPU)
	]->[
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~id_CPU>)
	]

// TODO Acho que teremos N RAS para N QE, como modelar isto, onde crio tid_IAS que aparece também em Register_QE? (possivelmente num local e depois input do estado para o outro?)
// TODO Talvez mudar nome para associate em vez de register? E é preciso a key!
rule Register_CAS:
	[
		!ID_IAS(~id_IAS),
		!ID_CAS(~id_CAS),
		Fr(~tid_IAS),
		Fr(~tid_CAS),
		Fr(~subscription_key)
	]--[
		Register_CAS(~id_IAS, ~id_CAS, ~tid_IAS, ~tid_CAS)
	]->[
		State_CAS(~tid_CAS, 'idle', <~id_CAS, ~tid_IAS, ~subscription_key>),
		State_IAS(~tid_IAS, 'idle', <~id_IAS, ~tid_CAS, ~subscription_key>)
	]



rule Frank_1:
	let
		// report_key = sgx_get_key(<~MRENCLAVE, 'report', ~nonce>)
		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

		// TODO Usar `real(id_CPU)` ou coisa parecida?
		// Posso depois experimentar ter isto num create, e fazer create desse agente (placeholder) falso para ver se adversário consegue invocar regra mas sem a função...

		data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		so = <~hF>
	in
	[
		//TODO O que utilizar como C e p ? Os IDs de CPU e enclave? Repensar!
		// !Enclave($C, $p, $MRENCLAVE, $MRSIGNER, ~nonce)
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~id_CPU>),
		Fr(~hF)
	]--[
		Progress_F1(~tid_Enclave, report)
	]->[
		State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~id_CPU>),
		AgSt('enclave', $F, '1', so),
		Out(report)
	]

rule Frank_2:
	let
		si = <~hF>
		so = <~hF>

		// cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)> // parte de baixo
		//TODO Não é necessário, apenas para ver se pattern funciona... problema do sig_QE no IAS
		//523 quote = <content, sign(content, ~ak), cert>

		//TEMP: desnecessário:
		// quote = <content, sign(content, ~ak), cert>
		//FIXME check this okay **** 11
		//TEMP 9.21: quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
		// NOTE Frank 2 não tem IAS pub key! Portanto acima não funcionaria: wrong ???
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sig_IAS>
	in
	[
		AgSt('enclave', $F, '1', si),
		State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~id_CPU>),
		// !Enclave($C, $p, $MRENCLAVE, $MRSIGNER, ~nonce),
		// !Pk($RAS, pub),
		// Fr(~session_key),
		In(quote)
	]--[
		Progress_F2(~tid_Enclave, quote)
	]->[
		AgSt('enclave', $F, '2', so),
		State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~id_CPU>),
		Out(quote)
		//TODO quote tem thread ID? E enviar através de túnel TLS? (enviar fora de túnel OK sinigifca que mais robusto do que com túnel, portanto assumption stronger in model)
		// Out(aenc(~session_key, pub)),
		// Out(senc(quote, ~session_key))
	]

//[color=DAAADA]
rule Frank_3:
	let
		si = <~hF>
		// // uid = <$prog,$eidA,$pidA>
		// m7 = <qA,qB>

		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>

		//certified_report = <avr_data, sign(avr_data, rsk)>
		// certified_report = <avr_data, signature>
		avr = <avr_data, sign(avr_data, ~priv_IAS)>
	in
	[
		AgSt('enclave', $F, '2', si),
		State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~id_CPU>),
		// !IAS_pub($IAS, pk(~rsk)), // assume IAS public key hardcoded
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		In(avr)
		// In(senc(certified_report, ~session_key))
	]--[
		Progress_F3(~tid_Enclave, avr)
		// Eq(true, verify(signature, avr_data, pk(~rsk)))
	]->[
	]



//REVIEW
/**
** The Quoting Enclave receives a report from an enclave, and
** produces a certified (signed by AK) quote for that enclave.
** The quote normally contains enclave measurement, etc, but in
** this case we only sign over the enclave identity (can be expanded).
**
** Receives local attestation from E (via A), and produces a quote.
**/
rule QE_new [color=AADADA]:
	let
		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

		// cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)>
		// //NOTE Não é necessário estar aqui, mas ver se assim termina
		// //TODO remove

		// data = <'hA'>
		// Remover para suportar múltiplos enclaves TODO
		// body = <$eid, $pid, $MRENCLAVE, data>
		// report = <body, CMAC(body, report_key)>
		data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
		// FIXME Não é preciso aqui chave pública do QE para que Intel consiga verificar a assinatura do QE sobre o 'content'? FIXED: adicionei pub QE
	in
	[
		// !QE($pid, ~ak, cert, ~nonce),
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		// !IAS_pub($IAS, pk(~isk)), //TODO remove //NOTE Isto causava problemas e tinha estado falsificado, mas ao comentar já funciona... provavelmente isto iniciava também setup antigo e criava conflitos!
		In(report)
	]--[
		Progress_QE_new_1(~tid_QE, ~tid_CPU, report, quote)
	]->[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		Out(quote)
	]

// Receive M13, Send M14
rule CAS_2_new:
	let
		// so = <~tid, ~client_session_key, ~server_session_key, ~ssk2>
		// //pub = pk(~ltk_IAS)
		//
		// // cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)> // parte de baixo
		// //TODO Não é necessário, apenas para ver se pattern funciona... problema do sig_QE no IAS
		// //523 quote = <content, sign(content, ~ak), cert>
		so = <~tid_RA>
		aep = <quote, ~subscription_key>
	in
	[
		// !CAS($RAS, ~subscription_key, ~ltk),
		State_CAS(~tid_CAS, 'idle', <~id_CAS, ~tid_IAS, ~subscription_key>),
		Fr(~tid_RA),
		In(quote)

		// Fr(~tid),
		// !Pk($IAS, pub),                // retrieve server public key
		// //In(quote),
		// //In(aenc(quote, pk(~ltk))),
		// In(aenc(~client_session_key, pk(~ltk))),
		// In(senc(quote, ~client_session_key)),
		// //In(<quote, '1111'>),
		// Fr(~ssk2),
		// Fr(~server_session_key)        // TLS session key
	]--[
		Progress_CAS_2(~tid_CAS, ~tid_IAS, ~tid_RA, quote, aep)
	]->[
		State_CAS(~tid_CAS, 'forwarding', <~id_CAS, ~tid_IAS, ~subscription_key>),
		AgSt('CAS', $CAS, 'forwarding', so),
		// AgSt('RAS', $RAS, 'forwarding', so),
		// Out(aenc(<~server_session_key,~ssk2>, pub)),
		// //Out(aenc(~ssk2, pub)),
		// Out(senc(<quote, ~subscription_key>, ~server_session_key))

		// Out(aep) // NOTE using encrypted
		// FIXME replay attack, nonce?
		Out(<~tid_RA, senc(aep, transport_key($CAS, $IAS, ~tid_RA))>)
		// adversário pode substituir tid mas não obter chave: only DoS
	]
	//TODO forwarding or attesting ?

// rule CAS_3_new:
// 	let
// 		// si = <~tid, ~client_session_key, ~server_session_key, ~ssk2>
// 		si = <~tid_RA>
// 	in
// 	[
// 		State_CAS(~tid_CAS, 'forwarding', <~id_CAS, ~tid_IAS, ~subscription_key>),
// 		AgSt('CAS', $CAS, 'forwarding', si),
// 		// In(senc(avr, ~ssk2))
// 		// In(avr)
// 		In(senc(avr, transport_key($IAS, $CAS, ~tid_RA)))
// 	]--[
// 		Progress_CAS_3(~tid_CAS, ~tid_IAS, ~tid_RA, avr)
// 	]->[
// 		State_CAS(~tid_CAS, 'idle', <~id_CAS, ~tid_IAS, ~subscription_key>),
// 		// Out(senc(avr, ~client_session_key))
// 		Out(avr)
// 	]

// REVIEW
/**
** The IAS receives a signed quote from an enclave (via RAS), and
** produces a signed report containing the verification result.
**
** The IPK is private, but the RPK is public.
**/
rule IAS_new [color=DADADA]:
	let
		// //cert_QE = <pid, pk(~ak), $IAS, signature>
		// //5 cert_QE = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)>
		// cert_QE = <$pid, pk(~ak), $IAS, signature>
		//
		// status = verify(signature, <$pid, pk(~ak), $IAS>, pk(~isk))
		// //TODO com macros aqui como sig ou I sem dollar funciona?
		//
		// status = verify(sign(pk(~priv_QE), ~priv_IAS), pk(~priv_QE), pk(~priv_IAS))
		// FIXME para isto funcionar preciso chave pública do QE que não tenho!
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
		//
		// TODO open up quote, and valide content (is enclave licensed? CPU?)

		// //cert_QE = <pid, pk(~ak), $IAS, signature>
		// //5 cert_QE = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)>
		// cert_QE = <$pid, pk(~ak), $IAS, signature>
		//
		// status = verify(signature, <$pid, pk(~ak), $IAS>, pk(~isk))
		// //TODO com macros aqui como sig ou I sem dollar funciona?
		//
		// // Attestation Evidence Payload: *** only using `quote` ***
		// //1 quote = <content, sign(content, ~ak), certificate>
		// quote = <content, sig_QE, cert_QE>  // quote body || quote signature
		// //6 quote = <content, sign(content, ~ak), cert_QE>  // quote body || quote signature
		aep = <quote, ~subscription_key>     // quote||manifest||nonce
		//3 aep = <content, sign(content, ~ak), cert_QE>

		// Attestation Verification Report
		//quote_status = verify(qs,qb,ipk)
		// quote_status, quote_body, etc in IAS spec... use correct names ??? TODO
		// avr_data = <status, content>  // many fields, see IAS spec // 11
		avr_data = <'OK', content>  // many fields, see IAS spec
		avr = <avr_data, sign(avr_data, ~priv_IAS)>

		//aep = <content, sign(content, ~ak)>
		//aep = <content, sign(content, ~ak), certificate>
		//avr = <content, sign(content, rsk)>
	in
	[
		// !IAS($IAS, ~isk, ~rsk, ~ltk, ~subscription_key),
		// In(aenc(<~server_session_key,~ssk2>, pk(~ltk))),
		// In(senc(aep, ~server_session_key))
		!Keys_IAS(~id_IAS, ~priv_IAS),
		State_IAS(~tid_IAS, 'idle', <~id_IAS, ~tid_CAS, ~subscription_key>),
		// In(aep)
		In(<~tid_RA, senc(aep, transport_key($CAS, $IAS, ~tid_RA))>)
	]--[
		Progress_IAS_new(~tid_IAS, ~tid_CAS, aep, avr),

		// verify IAS signature over public key of QE
		Eq(true, verify(sign(pk(~priv_QE), ~priv_IAS), pk(~priv_QE), pk(~priv_IAS))),

		// verify QE signature over contents of quote
		Eq(true, verify(sign(content, ~priv_QE), content, pk(~priv_QE)))
	]->[
		State_IAS(~tid_IAS, 'idle', <~id_IAS, ~tid_CAS, ~subscription_key>),
		// Out(avr)
		Out(senc(avr, transport_key($IAS, $CAS, ~tid_RA)))

		// Out(senc(avr, ~server_session_key))
		// Out(<$IAS,$RAS,senc(avr, ~server_session_key)>)
		// Out(senc(avr, ~ssk2))
	]






/******************************************************** */

restriction Equality:
	"All x y #i. Eq(x,y)@i ==> x=y"

// restriction Inequality:
// 	"All x #i. Neq(x,x) @i ==> F"

restriction OnlyOnce:
	"All #i #j. OnlyOnce() @#i & OnlyOnce() @#j ==> #i = #j"


// E1 e E2 são o mesmo enclave mas a executar em processadores diferentes: E1 no CPU_1, e E2 e E3 no CPU_3.
lemma setup: exists-trace
	"
	Ex QE_1 QE_3 E1 E2 E3 MRENCLAVE_1 MRSIGNER_1 MRENCLAVE_3 MRSIGNER_3 tid_E1 tid_E2 tid_E3 tid_QE_1 tid_QE_3 tid_CPU_1 tid_CPU_3 IAS CPU_1 CPU_3 CAS tid_CAS tid_IAS #t11 #t12 #t13 #t21 #t22 #t23 #t31 #t32 #t33 #t41 #t42 #t51 #t52 #t61 #t62.

	Create_Enclave(E1, MRENCLAVE_1, MRSIGNER_1) @ #t11 & Licensing(E1, IAS) @ #t12 & Binding(tid_E1, E1, CPU_1) @ #t13 &

	Create_Enclave(E2, MRENCLAVE_1, MRSIGNER_1) @ #t21 & Licensing(E2, IAS) @ #t22 & Binding(tid_E2, E2, CPU_3) @ #t23 &

	Create_Enclave(E3, MRENCLAVE_3, MRSIGNER_3) @ #t31 & Licensing(E3, IAS) @ #t32 & Binding(tid_E3, E3, CPU_3) @ #t33 &

	Create_QE(QE_1) @ #t41 & Provision(IAS, QE_1, CPU_1, tid_QE_1, tid_CPU_1) @ #t42 &

	Create_QE(QE_3) @ #t51 & Provision(IAS, QE_3, CPU_3, tid_QE_3, tid_CPU_3) @ #t52 &

	Create_CAS(CAS) @ #t61 & Register_CAS(IAS, CAS, tid_IAS, tid_CAS) @ #t62 &

	t31 < t32 & t32 < t33
	"

// Provar caminho ...
lemma Frank: exists-trace
	"
	// Ex tid_Enclave tid_QE report quote tid_CAS tid_IAS tid_RA aep avr #t1 #t2 #t3 #t4 #t5 #t6 #t7.
	Ex
		id_IAS id_CAS id_QE id_CPU id_Enclave MRENCLAVE MRSIGNER
		tid_CPU tid_QE
		tid_Enclave report quote tid_CAS tid_IAS tid_RA aep avr
	#s1 #s2 #s3 #s4 #s5 #s6 #s7 #s8 #s9
	#t1 #t2 #t3 #t4 #t5.// #t6 #t7.

	Create_IAS(id_IAS) @ s1 &
	Create_CAS(id_CAS) @ s2 &
	Create_QE(id_QE) @ s3 &
	Create_CPU(id_CPU) @ s4 &
	Create_Enclave(id_Enclave, MRENCLAVE, MRSIGNER) @ s5 &

	Provision(id_QE, id_CPU, id_IAS, tid_QE, tid_CPU) @ s6 &
	Licensing(id_Enclave, id_IAS) @ s7 &
	Binding(tid_Enclave, id_Enclave, id_CPU) @ s8 &
	Register_CAS(id_IAS, id_CAS, tid_IAS, tid_CAS) @ s9 &

	Progress_F1(tid_Enclave, report) @ t1 &
	Progress_QE_new_1(tid_QE, tid_CPU, report, quote) @ t2 &
	Progress_F2(tid_Enclave, quote) @ t3
	&
	Progress_CAS_2(tid_CAS, tid_IAS, tid_RA, quote, aep) @ t4
	&
	Progress_IAS_new(tid_IAS, tid_CAS, aep, avr) @ t5
	// &
	// Progress_CAS_3(tid_CAS, tid_IAS, tid_RA, avr) @ t6 &
	// Progress_F3(tid_Enclave, avr) @ t7
	"

end
