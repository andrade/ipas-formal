/**
** Protocol: AS v3
** Author:   Daniel Andrade
** Date:     03/2021
** Status:   WIP
**/

theory ASv3
begin

builtins: hashing, signing, diffie-hellman

functions:
	CMAC/2,                  // RFC 4493
	SHA/1,
	real/1 [private],
	sgx_get_key/1

// functions: enmac/2, demac/3
// equations: demac(enmac(m, k), m, k) = true

rule Create_IAS:
	[
		Fr(~id_IAS),
		Fr(~priv_IAS)
	]--[
		OnlyOnce(),
		Create_IAS(~id_IAS)
	]->[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS)
	]

rule Reveal_IAS:
	[ !Keys_IAS(id_IAS, k) ]--[ Reveal_IAS() ]->[ Out(k) ]

rule Create_QE:
	[ Fr(~id_QE) ]--[ Create_QE(~id_QE) ]->[ ID_QE(~id_QE) ]

rule Create_Enclave:
	[
		Fr(~id_Enclave),
		Fr(~MRENCLAVE),
		Fr(~MRSIGNER)
	]--[
		OnlyOneEnclave(), // TEMP restringir
		Create_Enclave(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]->[
		ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]

rule Create_CPU:
	[
		Fr(~id_CPU)
	]--[
		Create_CPU(~id_CPU)
	]->[
		ID_CPU(~id_CPU)
	]

// Provision CPU and QE: essentially registers these two agents with Intel
rule Provisioning:
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		ID_QE(~id_QE),
		ID_CPU(~id_CPU),
		Fr(~tid_QE),
		// Fr(~priv_QE), // attestation key for QE, signs quotes
		Fr(~tid_CPU)
	]--[
		Provision(~id_QE, ~id_CPU, ~id_IAS, ~tid_QE, ~tid_CPU)
	]->[
		// !State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		!State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_IAS>),
		!State_CPU(~tid_CPU, 'Provisioning_CPU', <~id_CPU, ~tid_QE, ~id_QE, ~id_IAS, sign(~id_CPU, ~priv_IAS), pk(~priv_IAS)>)
	]

// TODO Alterar whitelist de acordo com código
// Whitelist enclave
rule Licensing:
	let
		// Enclave ID, IAS ID, IAS signature over Enclave ID, IAS public key
		license = <~id_Enclave, ~MRENCLAVE, ~MRSIGNER, ~id_IAS, sign(<~id_Enclave, ~MRENCLAVE, ~MRSIGNER>, ~priv_IAS), pk(~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]--[
		Licensing(~id_Enclave, ~id_IAS)
	]->[
		!License(~id_Enclave, license)
	]

// TODO alteração para instance, TBC
// Bind enclave to CPU: results in instance of this enclave running on this CPU
rule Binding:
	[
		!State_CPU(~tid_CPU, 'Provisioning_CPU', <~id_CPU, ~tid_QE, ~id_QE, ~id_IAS, sign(~id_CPU, ~priv_IAS), pk(~priv_IAS)>),
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		Fr(~tid_Enclave)
		// isto acaba por ser Thread ID de instância do enclave
		// TODO mod para fresh ~tid_Instance
	]--[
		Binding(~tid_Enclave, ~id_Enclave, ~id_CPU, ~tid_CPU)
	]->[
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, license, ~tid_CPU, ~id_CPU>)
	]

rule DH [color=F4D03F]:
	[ Fr(~k) ]-->[ !DH_private($id, ~k), !DH_public($id, 'g'^~k), Out('g'^~k) ]

rule Reveal_DH:
	[ !DH_private(id, k) ]--[ Leak_private_DH(id) ]->[ Out(k) ]

// Establish a communication channel between A and B by associated Thread IDs
rule Connect:
	[
		State_Enclave(~tid_E1, 'bound', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1>),
		State_Enclave(~tid_E2, 'bound', <~id_Enclave, license, ~tid_CPU_2, ~id_CPU_2>)
	]--[
		Connected(~tid_E1, ~tid_E2)
	]->[
		AState(~tid_E1, 'connected', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, ~tid_E2>),
		BState(~tid_E2, 'connected', <~id_Enclave, license, ~tid_CPU_2, ~id_CPU_2, ~tid_E1>)
	]

rule A1 [color=D7BDE2]:
	let
		m7 = <~ANonce, APublic>
	in
	[
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		// !License(~id_Enclave, license),
		AState(~tid_Alice, 'connected', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, ~tid_Boris>),
		Fr(~ANonce),
		!DH_private($A, ~APrivate),
		!DH_public($A, APublic)
	]--[
		Progress_A1(~tid_Alice, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m7)

		// , Eq('g'^~APrivate, APublic) // TODO remove, dummy test
	]->[
		AState(~tid_Alice, 'TODO', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, ~tid_Boris>),
		Out(m7)
	]

rule B2 [color=D2B4DE]:
	let
		license = <~id_Enclave, ~MRENCLAVE, ~MRSIGNER, ~id_IAS, sign(<~id_Enclave, ~MRENCLAVE, ~MRSIGNER>, ~priv_IAS), pk(~priv_IAS)>

		m7 = <~ANonce, APublic>

		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU_2)>)

		// data = h(<APublic, BPublic, VK>)
		// REVIEW Utilizo os nonces em vez de VK
		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
		body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		m8 = report
	in
	[
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		// !License(~id_Enclave, license),
		BState(~tid_Boris, 'connected', <~id_Enclave, license, ~tid_CPU_2, ~id_CPU_2, ~tid_Alice>),
		Fr(~BNonce),
		!DH_private($B, ~BPrivate),
		!DH_public($B, BPublic),
		In(m7)
	]--[
		Progress_B2(~tid_Boris, ~tid_Alice, ~tid_CPU_2, $B, ~id_Enclave, ~id_CPU_2, m7, m8)
	]->[
		BState(~tid_Boris, 'LA', <~id_Enclave, license, ~tid_CPU_2, ~id_CPU_2, $B, ~BNonce, ~BPrivate, BPublic, ~tid_Alice, ~ANonce, APublic>),
		Out(m8)
	]

rule B3 [color=D2B4DE]:
	let
		license = <~id_Enclave, ~MRENCLAVE, ~MRSIGNER, ~id_IAS, sign(<~id_Enclave, ~MRENCLAVE, ~MRSIGNER>, ~priv_IAS), pub_IAS>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
		body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		content = <body>
		quote = <content, sign(content, ~priv_IAS)>
		m9 = quote
		// TODO modificar quote e talvez remover este bloco, licença, etc.

		KDK = APublic^~BPrivate
		SMK = CMAC('SMK', KDK)

		x = <~BNonce, BPublic, quote>
		m10 = <x, CMAC(x, SMK)>
		// m10 = <~BNonce, BPublic, quote>
	in
	[
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		// !License(~id_Enclave, license),
		BState(~tid_Boris, 'LA', <~id_Enclave, license, ~tid_CPU_2, ~id_CPU_2, $B, ~BNonce, ~BPrivate, BPublic, ~tid_Alice, ~ANonce, APublic>),
		In(m9)
	]--[
		Progress_B3(~tid_Boris, ~tid_Alice, ~tid_CPU_2, $B, ~id_Enclave, ~id_CPU_2, m9, m10)

		// FIXME chave agora IAS e não QE
		// , Eq(verify(sign(pk(~priv_QE), ~priv_IAS), pk(~priv_QE), pub_IAS), true)
		, Eq(verify(sign(content, ~priv_IAS), content, pub_IAS), true)

		, Reach_B3(~tid_Alice, ~tid_Boris, KDK) // FIXME need progress or not?
	]->[
		BState(~tid_Boris, 'TODO', <~id_Enclave, license, ~tid_CPU_2, ~id_CPU_2, $B, ~BNonce, ~BPrivate, BPublic, quote, KDK, SMK, ~tid_Alice, ~ANonce, APublic>),
		Out(m10)
	]

rule A4 [color=D7BDE2]:
	let
		license = <~id_Enclave, ~MRENCLAVE, ~MRSIGNER, ~id_IAS, sign(<~id_Enclave, ~MRENCLAVE, ~MRSIGNER>, ~priv_IAS), pk(~priv_IAS)>

		KDK = BPublic^~APrivate
		SMK = CMAC('SMK', KDK)

		x = <~BNonce, BPublic, BQuote>
		m10 = <x, CMAC(x, SMK)>
		// m10 = <~BNonce, BPublic, BQuote>

		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU_1)>)

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
		body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		m11 = report
	in
	[
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		// !License(~id_Enclave, license),
		AState(~tid_Alice, 'TODO', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, ~tid_Boris>),
		// !DH_public($A, APublic),
		In(m10)
	]--[
		Progress_A4(~tid_Alice, ~tid_Boris, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m10, m11)

		, Reach_A4(~tid_Alice, ~tid_Boris, KDK) // TEMP exists-trace r4
	]->[
		AState(~tid_Alice, 'LA', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, KDK, SMK, ~tid_Boris, ~BNonce, BPublic, BQuote>),
		Out(m11)
	]

rule A5 [color=D7BDE2]:
	let
		license = <~id_Enclave, ~MRENCLAVE, ~MRSIGNER, ~id_IAS, sign(<~id_Enclave, ~MRENCLAVE, ~MRSIGNER>, ~priv_IAS), pk(~priv_IAS)>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
		body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		content = <body>
		quote = <content, sign(content, ~priv_IAS)>
		m12 = AQuote

		m13a = AQuote
		m13b = BQuote
	in
	[
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		// !License(~id_Enclave, license),
		AState(~tid_Alice, 'LA', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, KDK, SMK, ~tid_Boris, ~BNonce, BPublic, BQuote>),
		// !DH_public($A, APublic),
		// !DH_public($B, BPublic),
		In(m12)
	]--[
		Progress_A5(~tid_Alice, ~tid_Boris, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m12, m13a, m13b)

		, Eq(verify(sign(content, ~priv_IAS), content, pk(~priv_IAS)), true)

		, Reach_A5(~tid_Alice, ~tid_Boris, AQuote, BQuote) // TEMP exists-trace
	]->[
		// TEMP comentar output para testar r5
		AState(~tid_Alice, 'RA', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, AQuote, KDK, SMK, ~tid_Boris, ~BNonce, BPublic, BQuote>),
		Out(m13a),
		Out(m13b)
	]

rule A6 [color=D7BDE2]:
	let
		license = <~id_Enclave, ~MRENCLAVE, ~MRSIGNER, ~id_IAS, sign(<~id_Enclave, ~MRENCLAVE, ~MRSIGNER>, ~priv_IAS), pub_IAS>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)

		AReport_body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		AReport_content = <AReport_body>
		AReport = <AReport_content, sign(AReport_content, ~priv_IAS)>
		m16a = AReport

		BReport_body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		BReport_content = <BReport_body>
		BReport = <BReport_content, sign(BReport_content, ~priv_IAS)>
		m16b = BReport

		x = <AReport, BReport>
		m17 = <x, CMAC(x, SMK)>
		// m17 = <AReport, BReport>
	in
	[
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		// !License(~id_Enclave, license),
		AState(~tid_Alice, 'RA', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, AQuote, KDK, SMK, ~tid_Boris, ~BNonce, BPublic, BQuote>),
		// !DH_public($A, APublic),
		// !DH_public($B, BPublic),
		In(m16a),
		In(m16b)
	]--[
		Progress_A6(~tid_Alice, ~tid_Boris, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m16a, m16b, m17),

		Reach_A6(~tid_Alice, ~tid_Boris, AReport, BReport, data),

		// A6_OUT_m17($A, $B, m17),

		Eq(true, verify(sign(AReport_content, ~priv_IAS), AReport_content, pub_IAS)),

		Eq(true, verify(sign(BReport_content, ~priv_IAS), BReport_content, pub_IAS))
	]->[
		// TEMP comentar output para testar r6
		AState(~tid_Alice, 'installing', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, AQuote, KDK, SMK, ~tid_Boris, ~BNonce, BPublic, BQuote, AReport, BReport>),
		Out(m17)
	]

rule B4 [color=D2B4DE]:
	let
		license = <~id_Enclave, ~MRENCLAVE, ~MRSIGNER, ~id_IAS, sign(<~id_Enclave, ~MRENCLAVE, ~MRSIGNER>, ~priv_IAS), pub_IAS>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)

		AReport_body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		AReport_content = <AReport_body>
		AReport = <AReport_content, sign(AReport_content, ~priv_IAS)>
		m16a = AReport

		BReport_body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		BReport_content = <BReport_body>
		BReport = <BReport_content, sign(BReport_content, ~priv_IAS)>

		x = <AReport, BReport>
		m17 = <x, CMAC(x, SMK)>
		// m17 = <AReport, BReport>

		// KDK = APublic^~BPrivate
		MK = CMAC('MK', KDK)
		SK = CMAC('SK', KDK)

		m18 = CMAC('OK', SMK)
		// m18 = 'OK'
	in
	[
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		// !License(~id_Enclave, license),
		BState(~tid_Boris, 'TODO', <~id_Enclave, license, ~tid_CPU_2, ~id_CPU_2, $B, ~BNonce, ~BPrivate, BPublic, BQuote, KDK, SMK, ~tid_Alice, ~ANonce, APublic>),
		// !DH_public($A, APublic),
		// !DH_public($B, BPublic),
		In(m17)
	]--[
		SessionKeys($A, $B, MK, SK),
		Progress_B4(~tid_Boris, ~tid_Alice, ~tid_CPU_2, $B, ~id_Enclave, ~id_CPU_2, m17, m18, MK, SK, ~BPrivate),

		// B4_IN_m17($A, $B, m17),

		Eq(true, verify(sign(AReport_content, ~priv_IAS), AReport_content, pub_IAS)),

		Eq(true, verify(sign(BReport_content, ~priv_IAS), BReport_content, pub_IAS))
	]->[
		// Não faz sentido ter?
		// State_Enclave(~tid_Boris, 'done', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2, ~tid_Alice, MK, SK>),
		Out(m18)
	]

rule A7 [color=D7BDE2]:
	let
		license = <~id_Enclave, ~MRENCLAVE, ~MRSIGNER, ~id_IAS, sign(<~id_Enclave, ~MRENCLAVE, ~MRSIGNER>, ~priv_IAS), pub_IAS>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)

		AReport_body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		AReport_content = <AReport_body>
		AReport = <AReport_content, sign(AReport_content, ~priv_IAS)>

		BReport_body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		BReport_content = <BReport_body>
		BReport = <BReport_content, sign(BReport_content, ~priv_IAS)>

		m18 = CMAC('OK', SMK)
		// m18 = 'OK'

		// KDK = BPublic^~APrivate
		MK = CMAC('MK', KDK)
		SK = CMAC('SK', KDK)
	in
	[
		// !Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		// !License(~id_Enclave, license),
		AState(~tid_Alice, 'installing', <~id_Enclave, license, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, AQuote, KDK, SMK, ~tid_Boris, ~BNonce, BPublic, BQuote, AReport, BReport>),
		// !DH_public($A, APublic),
		// !DH_public($B, BPublic),
		In(m18)
	]--[
		SessionKeys($A, $B, MK, SK),
		Progress_A7(~tid_Alice, ~tid_Boris, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m18, MK, SK, ~APrivate),

		Eq(true, verify(sign(AReport_content, ~priv_IAS), AReport_content, pub_IAS)),

		Eq(true, verify(sign(BReport_content, ~priv_IAS), BReport_content, pub_IAS))
	]->[
		// Não faz sentido ter?
		// State_Enclave(~tid_Alice, 'done', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, ~tid_Boris, MK, SK>)
	]

/**
** The Quoting Enclave receives a report from an enclave, and
** produces a certified (signed by AK) quote for that enclave.
**/
rule QE [color=AADADA]:
let
	report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

	// TEMP não funciona para Frank, etc. Apenas para testar com session_keys
	// data = h(<APublic, BPublic, ~ANonce, ~BNonce>)

	// 5.15: Este body não devia interessar, desde que CMAC correto.
	// 5.15: body = <$F, ~id_CPU, ~MRENCLAVE, data>
	// 11.10: body = <$i, ~id_CPU, ~MRENCLAVE, data>
	// 11.12: body = <id_Instance, ~id_CPU, ~MRENCLAVE, data>
	// 11.12: report = <body, CMAC(body, report_key)>

	// body = <$i, ~id_CPU, ~MRENCLAVE, data>
	// body = <id_Instance, ~id_CPU, ~MRENCLAVE, data>
	data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
	body = <$B, ~id_CPU, ~MRENCLAVE, data>
	report = <body, CMAC(body, report_key)>
	content = <body>
	// quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
	quote = <content, sign(content, ~priv_IAS)>
in
[
	// REVIEW Mudar para state em vez de 'idle' para aceitar ambos os casos ??
	// NOTE sendo estado linear temos apenas um QE por binding, TBC
	!State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_IAS>),
	In(report)
]--[
	Progress_QE(~tid_QE, ~tid_CPU, report, quote)
]->[
	// State_QE(~tid_QE, 'done', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
	Out(quote)
]

rule IAS [color=DADADA]:
let
	body = <$F, ~id_CPU, ~MRENCLAVE, data>
	content = <body>
	quote = <content, sign(content, ~priv_IAS)>

	report = <content, sign(content, ~priv_IAS)>
in
[
	// !ID_IAS(~id_IAS),
	!Keys_IAS(~id_IAS, ~priv_IAS),
	In(quote)
]--[
	Progress_IAS(~id_IAS, quote, report)//,

	// FIXME chave agora IAS e não QE
	// verify IAS signature over public key of QE
	// Eq(true, verify(sign(pk(~priv_QE), ~priv_IAS), pk(~priv_QE), pk(~priv_IAS))),

	// FIXME chave agora IAS e não QE
	// verify QE signature over contents of quote
	// Eq(true, verify(sign(content, ~priv_QE), content, pk(~priv_QE)))
]->[
	Out(report)
]



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



restriction Equality:
	"All x y #i. Eq(x,y)@i ==> x=y"

// restriction Inequality:
// 	"All x #i. Neq(x,x) @i ==> F"

restriction OnlyOnce:
	"All #i #j. OnlyOnce() @#i & OnlyOnce() @#j ==> #i = #j"

restriction OnlyOneEnclave:
	"All #i #j. OnlyOneEnclave() @#i & OnlyOneEnclave() @#j ==> #i = #j"

// lemma secrecy:
// 	"All k #i #j. Secret(k) @i & K(k) @j ==> F"

// restriction r17:
// 	"All A B m17 #i. B4_IN_m17(A, B, m17) @ i ==> (
// 		// (Ex #j. K(m17) @ j & j < i) |
// 		(Ex #j. A6_OUT_m17(A, B, m17) @ j)
// 	)"

// lemma s1 [sources]:
// 	"All A B m17 #i. B4_IN_m17(A, B, m17) @ i ==> (
// 		// (Ex #j. K(m17) @ j & j < i) |
// 		(Ex #j. A6_OUT_m17(A, B, m17) @ j)
// 	)"

lemma connection: exists-trace
	"Ex tid_Alice tid_Boris #k. Connected(tid_Alice, tid_Boris) @ #k"


// WIP: Alice and Boris
lemma temp_one: exists-trace
	"
	Ex
		A tid_Alice id_CPU_1
		B tid_Boris id_CPU_2
		id_Enclave MRENCLAVE MRSIGNER
		id_QE_1 id_QE_2 tid_QE_1 tid_QE_2 tid_CPU_1 tid_CPU_2
		id_IAS
		MK SK APrivate BPrivate
		m7 m8 m9 m10 m11 m12 m13a m13b m16a m16b m17 m18
	#s1 #s2 #s3 #s4 #s5 #s6
	#s11 #s12 #s13 #s15 #s16 #s17
	#t11 #t14 #t15 #t16 #t17
	#t22 #t23 #t24
	#t51 #t52
	#t71 #t72.

	not( APrivate = BPrivate ) &

	Create_IAS(id_IAS) @ s1 &
	Create_CPU(id_CPU_1) @ s2 &
	Create_CPU(id_CPU_2) @ s3 &
	Create_QE(id_QE_1) @ s4 &
	Create_QE(id_QE_2) @ s5 &
	Create_Enclave(id_Enclave, MRENCLAVE, MRSIGNER) @ s6 &

	Provision(id_QE_1, id_CPU_1, id_IAS, tid_QE_1, tid_CPU_1) @ s11 &
	Provision(id_QE_2, id_CPU_2, id_IAS, tid_QE_2, tid_CPU_2) @ s12 &
	Licensing(id_Enclave, id_IAS) @ s13 &
	Binding(tid_Alice, id_Enclave, id_CPU_1, tid_CPU_1) @ s15 &
	Binding(tid_Boris, id_Enclave, id_CPU_2, tid_CPU_2) @ s16 &

	Connected(tid_Alice, tid_Boris) @ s17 &

	Progress_A1(tid_Alice, tid_CPU_1, A, id_Enclave, id_CPU_1, m7) @ t11 &
	Progress_B2(tid_Boris, tid_Alice, tid_CPU_2, B, id_Enclave, id_CPU_2, m7, m8) @ t22 &
	Progress_QE(tid_QE_2, tid_CPU_2, m8, m9) @ t51 &
	Progress_B3(tid_Boris, tid_Alice, tid_CPU_2, B, id_Enclave, id_CPU_2, m9, m10) @ t23 &
	Progress_A4(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m10, m11) @ t14 &
	Progress_QE(tid_QE_1, tid_CPU_1, m11, m12) @ t52 &
	Progress_A5(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m12, m13a, m13b) @ t15 &
	Progress_IAS(id_IAS, m13a, m16a) @ t71 &
	Progress_IAS(id_IAS, m13b, m16b) @ t72 &
	Progress_A6(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m16a, m16b, m17) @ t16 &
	Progress_B4(tid_Boris, tid_Alice, tid_CPU_2, B, id_Enclave, id_CPU_2, m17, m18, MK, SK, BPrivate) @ t24 &
	Progress_A7(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m18, MK, SK, APrivate) @ t17 &

	t11 < t22 & t22 < t51 & t51 < t23 & t23 < t14 & t14 < t52 & t52 < t15 &
	t15 < t71 & t15 < t72 & t71 < t16 & t72 < t16 & t16 < t24 & t24 < t17
	"

/**
** Ensure session keys can be setup between honest agents.
**
** There is a trace where all equality checks are satisfied and
** session keys MK, SK are setup without revealing private DH keys.
**/
lemma session_keys: exists-trace
	"
		(All x y #i. Eq(x,y)@i ==> x=y) &
		(Ex A B MK SK #k.
			SessionKeys(A, B, MK, SK) @ k &
			not(Ex #r. Leak_private_DH(A) @ r) &
			not(Ex #r. Leak_private_DH(B) @ r) &
			not(Ex #r. Reveal_IAS() @ r)
		)
	"


// To remove
lemma session_keys_wrong: exists-trace
	"Ex A B MK SK #k. SessionKeys(A, B, MK, SK) @ k"

lemma b2: exists-trace
	"Ex tid_Alice tid_Boris A B E tid_CPU_1 tid_CPU_2 id_CPU_1 id_CPU_2 m7 m8 #i #j.

	Progress_A1(tid_Alice, tid_CPU_1, A, E, id_CPU_1, m7)@i &

	Progress_B2(tid_Boris, tid_Alice, tid_CPU_2, B, E, id_CPU_2, m7, m8)@j &

	i<j"

lemma r3: exists-trace
	"Ex tid_Alice tid_Boris A B E tid_CPU_1 tid_CPU_2 id_CPU_1 id_CPU_2 tid_QE m7 R Q m10 #i #j #k #l.

	Progress_A1(tid_Alice, tid_CPU_1, A, E, id_CPU_1, m7)@i &

	Progress_B2(tid_Boris, tid_Alice, tid_CPU_2, B, E, id_CPU_2, m7, R)@j &

	Progress_QE(tid_QE, tid_CPU_2, R, Q)@ k &

	Progress_B3(tid_Boris, tid_Alice, tid_CPU_2, B, E, id_CPU_2, Q, m10)@l &

	i<j & j < k"

lemma Reach_QE: exists-trace
	"Ex tid_QE tid_CPU R Q #i. Progress_QE(tid_QE, tid_CPU, R, Q) @ #i"

lemma b3: exists-trace
	"Ex tid_Alice tid_Boris B E tid_QE tid_CPU id_CPU R Q m10 #i #j. Progress_QE(tid_QE, tid_CPU, R, Q) @ i & Progress_B3(tid_Boris, tid_Alice, tid_CPU, B, E, id_CPU, Q, m10) @ j & i<j"


// Partial trace: derivation key setup correctly between A and B
lemma A4: exists-trace
	"
		Ex tid_Alice tid_Boris KDK #j #k.
		Reach_B3(tid_Alice, tid_Boris, KDK) @ #j &
		Reach_A4(tid_Alice, tid_Boris, KDK) @ #k &
		#j < #k
	"

// Perceber se A5 é alcançado. Comentar output de A5.
lemma r5: exists-trace
	"Ex A B AQuote BQuote #k. Reach_A5(A, B, AQuote, BQuote) @ #k"

lemma r5c: exists-trace
	"Ex A B AQuote BQuote #j #k. Connected(A, B) @ j & Reach_A5(A, B, AQuote, BQuote) @ #k"

lemma r6: exists-trace
	"Ex A B AReport BReport d #j #k. Connected(A, B) @ j & Reach_A6(A, B, AReport, BReport, d) @ #k"

lemma session_keys_secrecy:
	"not(
		Ex A B MK SK #k.
			SessionKeys(A, B, MK, SK) @k &
			((Ex #i. K(MK) @i) | (Ex #i. K(SK) @i)) &
			not(Ex #r. Leak_private_DH(A) @ r) &
			not(Ex #r. Leak_private_DH(B) @ r)
	)
	"

lemma honest_keys: exists-trace
	"Ex
		A tid_Alice id_CPU_1 tid_CPU_1
		B tid_Boris id_CPU_2 tid_CPU_2
		id_Enclave
		m1 m2
		MK SK APrivate BPrivate
	#t1 #t2.

	not(APrivate=BPrivate) &

	Progress_B4(tid_Boris, tid_Alice, tid_CPU_2, B, id_Enclave, id_CPU_2, m1, m2, MK, SK, BPrivate) @ t1 &
	Progress_A7(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m2, MK, SK, APrivate) @ t2 &

	not(Ex #r. Leak_private_DH(APrivate) @ r) &
	not(Ex #r. Leak_private_DH(BPrivate) @ r) &

	t1 < t2
	"

// TODO Lots of leftovers from tests, needs cleanup

end
