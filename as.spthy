/**
** Protocol: AS v3
** Author:   Daniel Andrade
** Date:     03/2021
** Status:   WIP
**/

theory ASv3
begin

builtins: hashing, signing, diffie-hellman
builtins: asymmetric-encryption, symmetric-encryption

functions:
	CMAC/2,                  // RFC 4493
	SHA/1,
	//isk/0 [private],         // Intel Signing Key
	//rsk/0 [private],         // Report Signing Key
	sgx_get_key/1
	//sgx_get_key/1 [private]  //TODO Why this doesn't work?

// IAS and RAS share subscription key
rule SharedKey:
	[ Fr(~k) ] --> [ SharedKey1($p, ~k), SharedKey2($q, ~k) ]
//FIXME Mesma shared key fact name problemático! *********** FIXME

// Register a public-key pair
rule Register_pk:
	[ Fr(~ltk) ] --> [ !Ltk($id, ~ltk), !Pk($id, pk(~ltk)) ]

// Adversary can read any public key
rule Get_pk:
	[ !Pk(id, pub) ] --> [ Out(pub) ]

rule Register_Intel [color=DADADA]:
	// let
	// 	ipk = pk(isk)              // Intel Public Key
	// 	rpk = pk(rsk)              // Report Public Key
	// in
	[
		Fr(~isk),                   // Intel Signing Key
		Fr(~rsk),                   // Report Signing Key
		!Ltk($IAS, ~ltk),             // TLS
		SharedKey1($IAS, ~k)         // subscription key (allows only one RAS)
	]--[
		OnlyOnce(),
		Secret(~isk),
		Secret(~rsk)
	]->[
		!IAS($IAS, ~isk, ~rsk, ~ltk, ~k),
		!IAS_pub($IAS, pk(~isk)),
		!IAS_pub($IAS, pk(~rsk))
		// ,
		// Out(pk(rsk))  // Give the Report Public Key to all entities
	]

rule Register_RAS:
	[
		SharedKey2($RAS, ~subscription_key),
		!Ltk($RAS, ~ltk),
		Fr(~tid)
	] --> [
		// !RAS($RAS, ~subscription_key, ~ltk)
		CAS(~tid, 'idle', <$RAS, ~subscription_key, ~ltk>)
	]
	//[ SharedKey2($id, ~k) ] --> [ !RAS($id, ~k) ]

rule Register_QE [color=AADADA]:
	let
		// subject name, subject key, issuer name, signature
		cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)>
	in
	[
		!IAS($IAS, ~isk, ~rsk, ~ltk, ~k),
		Fr(~ak),
		Fr(~nonce)
	]--[
		Secret(~isk),
		Secret(~rsk),
		Secret(~ak)
	]->[
		!QE($pid, ~ak, cert, ~nonce)
	]

//[color=FFCCAA]
rule Register_Enclave:
	// let
	// 	//metadata = <$MRENCLAVE, $MRSIGNER>
	//
	// 	//NOTE Obtida de função Get_Key
	// 	//1 report_key = sgx_get_key(<$eid,$pid,metadata,'report'>)
	// in
	[
		!QE($pid, ~ak, cert, ~nonce)
		// ~nonce é suposto ser key hierarchy? NOTE
	]--[
		Neq($MRENCLAVE, $MRSIGNER),
		Secret(~ak)
	]->[
		!Enclave($eid, $pid, $MRENCLAVE, $MRSIGNER, ~nonce)
	]
//
// rule Register_Enclave:
// 	[
// 		!QE($pid,~ak,cert)
// 	]-->[
// 		!Enclave($eid,$pid)
// 	]

// rule Get_Key:
// 	[
// 		In(<$eid,$pid,metadata,type>) // e.g. type='report'
// 	]--[
// 	]->[
// 		Out(sgx_get_key(<$eid,$pid,metadata,type>))
// 	]

// rule Register_Program:
// 	[
// 		!Enclave($eid,$pid,metadata)
// 	]-->[
// 		!Enclave($eid,$pid,metadata),
// 		!Program($prog,$eid,$pid)
// 	]

// /**
// ** Send tagged report to the network.
// **/
// rule Enclave_1:
// 	let
// 		request = <$prog,$eid,$pid,'report'>
// 		report_key = sgx_get_key(request)
// 		data = <$prog,$eid,$pid,~user_data>
//
// 		m = <data,CMAC(data,report_key)>
// 	in
// 	[
// 		!Program($prog,$eid,$pid),
//
// 		Fr(~user_data)
// 	]--[
// 		Enclave_O1(m)
// 	]->[
// 		Out(m)
// 	]
//
// rule Enclave_2:
// 	[
// 		!Program($prog,$eid,$pid),
// 		In(<report,sig>),
// 		In(rpk)
// 	]--[
// 		Enclave_I2(report),
// 		Eq(verify(sig,report,rpk),true)  // Verify IAS signed report
// 	]->[
// 	]

//[color=DAAADA]
rule Alice_1:
	let
		report_key = sgx_get_key(<$MRENCLAVE, 'report', ~nonce>)

		data = <'hA'>
		//body = <$A, $p, md, data>
		body = <$A, $p, $MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		so = <'hA'>
	in
	[
		!Enclave($A, $p, $MRENCLAVE, $MRSIGNER, ~nonce)
	]--[
		Progress_A1(report),
		Alice_O1($A, report),
		Secret(report_key)
	]->[
		AgSt('enclave1', $A, '1', so),
		Out(report)
	]

//[color=DAAADA]
rule Alice_2:
	// let
	// 	//FIXME get body her to extract hB and compare with hA in Eq
	// 	d = <hB> //2
	// 	b = <$B,$p2,md,d> //2
	// 	//1 qB = <<<b,cert>,sig>,t>
	// 	qB = <<b,cert>,t> //2
	// 	//m4 = <pubB,~nB,quoteB>
	// 	//m4 = <pubB,~nB,qB>
	// 	m4 = <$B,$A,pubB,~nB,qB>
	// 	// uid = <$prog,$eidA,$pidA>
	//
	//
	// 	// shared_secret = pubB^~ltkA
	// 	// KDK = CMAC(shared_secret,'0x00')
	// 	// SMK = CMAC(<'0x01','SMK','0x00','0x80','0x00'>,KDK)
	// 	// VK = CMAC(<'0x01','VK','0x00','0x80','0x00'>,SMK)
	// 	// hA = SHA(<'g'^~ltkA,pubB,VK>)
	// 	// h is sent as user data within the report
	// 	hA = SHA(<'g'^~ltkA,pubB>) //TEMP
	//
	// 	// prepare report for QE
	// 	///request = <$A,$p1,md,'report'>
	// 	///report_key = sgx_get_key(request)
	// 	data = <hA>                            // sgx_report_data_t
	// 	body = <$A,$p1,md,data>       // sgx_report_body_t
	// 	report = <body,CMAC(body,report_key)> // sgx_report_t
	// in
	let
		si = <'hA'>
		so = <'hA', ~session_key>

		// cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)> // parte de baixo
		//TODO Não é necessário, apenas para ver se pattern funciona... problema do sig_QE no IAS
		//523 quote = <content, sign(content, ~ak), cert>

		//TEMP: desnecessário:
		quote = <content, sign(content, ~ak), cert>
	in
	[
		AgSt('enclave1', $A, '1', si),
		!Enclave($A, $p, $MRENCLAVE, $MRSIGNER, ~nonce),
		!Pk($RAS, pub),
		Fr(~session_key),
		In(quote)
	]--[
		Progress_A2(quote),
		Alice_I2($A, quote),
		Alice_O2($A, quote),
		Eq(quote,quote)
	]->[
		AgSt('enclave1', $A, '2', so),
		//Out(quote)
		//Out(<quote, '1111'>)
		Out(aenc(~session_key, pub)),
		Out(senc(quote, ~session_key))
	]

//[color=DAAADA]
rule Alice_3:
	let
		si = <'hA', ~session_key>
		// // uid = <$prog,$eidA,$pidA>
		// m7 = <qA,qB>

		//certified_report = <avr_data, sign(avr_data, rsk)>
		certified_report = <avr_data, signature>
	in
	[
		AgSt('enclave1', $A, '2', si),
		!Enclave($A, $p, $MRENCLAVE, $MRSIGNER, ~nonce),
		!IAS_pub($IAS, pk(~rsk)), // assume IAS public key hardcoded
		//524 In(certified_report)
		In(senc(certified_report, ~session_key))
		//1 In(senc(<certified_report>, ~client_session_key))
	]--[
		Progress_A3(certified_report),
		Alice_I3($A, certified_report),
		Eq(true, verify(signature, avr_data, pk(~rsk)))
		//,Alice_O3($A,m7)
	]->[
		// State_E2(<~ltkA,~nA,pubB,~nB,KDK,SMK,VK,hA,quoteA,quoteB>),
		// Alice_3( ~alice, ~ltkA,~nA,hA,quoteA, pubB,~nB,quoteB, KDK,SMK,VK ),
		//AgSt($A, <~ltkA,~nA,quoteA,quoteB>),
		//Out(m7) // commented? FIXME these two lines?
	]

// rule Alice_4:
// 	let
// 		m10 = <rA,rB>
// 		m11 = <rA,rB>
// 		//uid = <$prog,$eidA,$pidA>
// 	in
// 	[
// 		!Enclave($A,$p1,md,report_key),
// 		// !Program($prog,$eidA,$pidA),
// 		In(m10),
// 		//State_E2(<~ltkA,~nA,pubB,~nB,KDK,SMK,VK,hA,qA,qB>)
// 		// Alice_3( ~alice, ~ltkA,~nA,hA,quoteA, pubB,~nB,quoteB, KDK,SMK,VK )
// 		AgSt($A, <~ltkA,~nA,quoteA,quoteB>)
// 	]--[
// 		Alice_I4($A,m10),
// 		Alice_O4($A,m11)
// 		//TODO At this point validate reports and derive MK/SK
// 	]->[
// 		//State_E2(<~ltkA,~nA,pubB,~nB,KDK,SMK,VK,hA,qA,qB,rA,rB>),
// 		//NOTE No State neede after this, ends here ????
// 		Out(m11)
// 	]

// rule Boris_1:
// 	let
// 		//m1 = <pubA,~nA>
// 		m1 = <$A,$B,pubA,~nA>
//
// 		pubB = 'g'^~ltkB  // public key of enclave B
//
// 		// shared_secret = pubA^~ltkB
// 		// KDK = CMAC(shared_secret,'0x00')
// 		// SMK = CMAC(<'0x01','SMK','0x00','0x80','0x00'>,KDK)
// 		// VK = CMAC(<'0x01','VK','0x00','0x80','0x00'>,SMK)
// 		// hB = SHA(<pubA,pubB,VK>)
// 		// hB is sent as user data within the report
// 		hB = SHA(<pubA,pubB>) //TEMP
//
// 		//request = <$prog,$eidB,$pidB,'report'>
// 		//request = <$B,$p2,md,'report'>
// 		//report_key = sgx_get_key(request)
// 		data = <hB>                           // sgx_report_data_t
// 		body = <$B,$p2,md,data>       // sgx_report_body_t
// 		report = <body,CMAC(body,report_key)> // sgx_report_t
//
// 		m2 = report
// 	in
// 	[
// 		!Enclave($B,$p2,md,report_key),
// 		// !Program($prog,$eidB,$pidB),
// 		//Fr(~boris),
// 		// se substituir isto por dois Fr já funciona, FIXME:
// 		In(m1),
// 		Fr(~ltkB),
// 		Fr(~nB)
// 	]--[
// 		Boris_I1($B,m1),
// 		Boris_O1($B,m2)
// 	]->[
// 		// State_E2(<~ltkB,~nB,pubA,~nA,KDK,SMK,VK,h>),
// 		// Boris_1( ~boris, ~ltkB,~nB,h, pubA,~nA, KDK,SMK,VK ),
// 		AgSt($B, <~ltkB,~nB>),
// 		//Out(<'g'^~ltkB,~nB,m>)
// 		Out(m2)
// 	]
//
// rule Boris_2:
// 	let
// 		pubB = 'g'^~ltkB
//
// 		// d = <report_data>
// 		// b = <$prog,$eidB,$pidB,d>
// 		// m = <$prog,$eidB,$pidB,b,cert>
// 		// qB = <m,signature>
//
// 		//m3 = qB
//
// 		m4 = <$B,$A,pubB,~nB,qB>
// 	in
// 	[
// 		!Enclave($B,$p2,md,report_key),
// 		// !Program($prog,$eidB,$pidB),  //TODO Create uid of this?
// 		In(qB),
// 		// State_E2(<~ltkB,~nB,pubA,~nA,KDK,SMK,VK,hB>)
// 		// Boris_1( ~boris, ~ltkB,~nB,hB, pubA,~nA, KDK,SMK,VK )
// 		AgSt($B, <~ltkB,~nB>)
// 	]--[
// 		Boris_I2($B,qB),
// 		Boris_O2($B,m4)
// 	]->[
// 		// State_E2(<~ltkB,~nB,pubA,~nA,KDK,SMK,VK,hB,qB>),
// 		// Boris_2( ~boris, ~ltkB,~nB,hB,qB, pubA,~nA, KDK,SMK,VK ),
// 		AgSt($B, <~ltkB,~nB,qB>),
// 		Out(m4)
// 	]

// rule Boris_3:
// 	let
// 		m11 = <rA,rB>
// 		//uid = <$prog,$eidB,$pidB>
// 	in
// 	[
// 		!Enclave($B,$p2,md,report_key),
// 		// !Program($prog,$eidB,$pidB),
// 		In(m11),
// 		// State_E2(<~ltkB,~nB,pubA,~nA,KDK,SMK,VK,hB,qB>)
// 		// Boris_2( ~boris, ~ltkB,~nB,hB,qB, pubA,~nA, KDK,SMK,VK )
// 		// AgSt(uid, <~ltkB,~nB>)
// 		AgSt($B, <~ltkB,~nB,qB>)
// 	]--[
// 		Boris_I3($B,m11)
// 		//TODO At this point validate reports and derive MK/SK
// 	]->[
// 		// State_E2(<~ltkB,~nB,pubA,~nA,KDK,SMK,VK,hB,qB,rA,rB>)
// 		//TODO Termina aqui?
// 	]

// rule Carol_1:
// 	let
// 		report_key = sgx_get_key(<$MRENCLAVE, 'report', ~nonce>)
//
// 		data = <'hC'>
// 		//body = <$A, $p, md, data>
// 		body = <$C, $r, $MRENCLAVE, data>
// 		report = <body, CMAC(body, report_key)>
//
// 		so = <'hC'>
// 	in
// 	[
// 		!Enclave($C, $r, $MRENCLAVE, $MRSIGNER, ~nonce)
// 	]--[
// 		Carol_O1($C, report),
// 		Secret(report_key)
// 	]->[
// 		AgSt('enclave2', $C, '1', so),
// 		Out(report)
// 	]
//
// rule Carol_2:
// 	// let
// 	// 	//FIXME get body her to extract hB and compare with hA in Eq
// 	// 	d = <hB> //2
// 	// 	b = <$B,$p2,md,d> //2
// 	// 	//1 qB = <<<b,cert>,sig>,t>
// 	// 	qB = <<b,cert>,t> //2
// 	// 	//m4 = <pubB,~nB,quoteB>
// 	// 	//m4 = <pubB,~nB,qB>
// 	// 	m4 = <$B,$A,pubB,~nB,qB>
// 	// 	// uid = <$prog,$eidA,$pidA>
// 	//
// 	//
// 	// 	// shared_secret = pubB^~ltkA
// 	// 	// KDK = CMAC(shared_secret,'0x00')
// 	// 	// SMK = CMAC(<'0x01','SMK','0x00','0x80','0x00'>,KDK)
// 	// 	// VK = CMAC(<'0x01','VK','0x00','0x80','0x00'>,SMK)
// 	// 	// hA = SHA(<'g'^~ltkA,pubB,VK>)
// 	// 	// h is sent as user data within the report
// 	// 	hA = SHA(<'g'^~ltkA,pubB>) //TEMP
// 	//
// 	// 	// prepare report for QE
// 	// 	///request = <$A,$p1,md,'report'>
// 	// 	///report_key = sgx_get_key(request)
// 	// 	data = <hA>                            // sgx_report_data_t
// 	// 	body = <$A,$p1,md,data>       // sgx_report_body_t
// 	// 	report = <body,CMAC(body,report_key)> // sgx_report_t
// 	// in
// 	let
// 		si = <'hC'>
// 		so = <'hC'>
// 	in
// 	[
// 		AgSt('enclave2', $C, '1', si),
// 		!Enclave($C, $r, $MRENCLAVE, $MRSIGNER, ~nonce),
// 		In(quote)
// 	]--[
// 		Carol_I2($C, quote),
// 		Carol_O2($C, quote),
// 		Eq(quote,quote)
// 	]->[
// 		AgSt('enclave2', $C, '2', so),
// 		Out(quote)
// 	]
//
// rule Carol_3:
// 	let
// 		si = <'hC'>
// 		// // uid = <$prog,$eidA,$pidA>
// 		// m7 = <qA,qB>
// 		certified_report = <avr_data, signature>
// 	in
// 	[
// 		AgSt('enclave2', $C, '2', si),
// 		!Enclave($C, $r, $MRENCLAVE, $MRSIGNER, ~nonce),
// 		!IAS_pub($IAS, pk(~rsk)),
// 		In(certified_report)
// 	]--[
// 		Carol_I3($C, certified_report),
// 		Eq(true, verify(signature, avr_data, pk(~rsk)))
// 		//,Carol_O3($A,m7)
// 	]->[
// 		// State_E2(<~ltkA,~nA,pubB,~nB,KDK,SMK,VK,hA,quoteA,quoteB>),
// 		// Carol_3( ~alice, ~ltkA,~nA,hA,quoteA, pubB,~nB,quoteB, KDK,SMK,VK ),
// 		//AgSt($A, <~ltkA,~nA,quoteA,quoteB>),
// 		//Out(m7) // commented? FIXME these two lines?
// 	]
//
// rule Dalia_1:
// 	let
// 		report_key = sgx_get_key(<$MRENCLAVE, 'report', ~nonce>)
//
// 		data = <'hD'>
// 		body = <$D, $p, $MRENCLAVE, data>
// 		report = <body, CMAC(body, report_key)>
//
// 		so = <'hD'>
// 	in
// 	[
// 		!Enclave($D, $p, $MRENCLAVE, $MRSIGNER, ~nonce)
// 	]--[
// 		Dalia_O1($D, report),
// 		Secret(report_key)
// 	]->[
// 		AgSt('enclave3', $D, '1', so),
// 		Out(report)
// 	]
//
// rule Dalia_2:
// 	let
// 		si = <'hD'>
// 		so = <'hD'>
// 	in
// 	[
// 		AgSt('enclave3', $D, '1', si),
// 		!Enclave($D, $p, $MRENCLAVE, $MRSIGNER, ~nonce),
// 		In(quote)
// 	]--[
// 		Dalia_I2($D, quote),
// 		Dalia_O2($D, quote),
// 		Eq(quote,quote)
// 	]->[
// 		AgSt('enclave3', $D, '2', so),
// 		Out(quote)
// 	]
//
// rule Dalia_3:
// 	let
// 		si = <'hD'>
//
// 		certified_report = <avr_data, signature>
// 	in
// 	[
// 		AgSt('enclave3', $D, '2', si),
// 		!Enclave($D, $p, $MRENCLAVE, $MRSIGNER, ~nonce),
// 		!IAS_pub($IAS, pk(~rsk)),
// 		In(certified_report)
// 	]--[
// 		Dalia_I3($D, certified_report),
// 		Eq(true, verify(signature, avr_data, pk(~rsk)))
// 	]->[
// 	]

/**
** The Quoting Enclave receives a report from an enclave, and
** produces a certified (signed by AK) quote for that enclave.
** The quote normally contains enclave measurement, etc, but in
** this case we only sign over the enclave identity (can be expanded).
**
** Receives local attestation from E (via A), and produces a quote.
**/
rule QE [color=AADADA]:
	let
		report_key = sgx_get_key(<$MRENCLAVE, 'report', ~nonce>)
		//TODO Consider adding pid for supporting multiple QE

		// cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)>
		//NOTE Não é necessário estar aqui, mas ver se assim termina

		data = <'hA'>
		body = <$eid, $pid, $MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		content = <body>
		quote = <content, sign(content, ~ak), cert>
	in
	[
		!QE($pid, ~ak, cert, ~nonce),
		// !IAS_pub($IAS, pk(~isk)),
		In(report)
	]--[
		Progress_QE(report,quote),

		Receive_QE($pid, report), //FIXME
		Send_QE($pid, quote),     //FIXME
		Secret(report_key)        //FIXME
	]->[
		Out(quote)
	]

/**
** The IAS receives a signed quote from an enclave (via RAS), and
** produces a signed report containing the verification result.
**
** The IPK is private, but the RPK is public.
**/
rule IAS [color=DADADA]:
	let
		//2 certificate = <$pid, pk(~ak), $I, sign(<$pid, pk(~ak), $I>, isk)>
		//3 certificate = <pid, pub, $I, sign(<pid, pub, $I>, isk)>
		// pid = subject (QE), pub = public key of QE, issuer, sig of issuer over rest of certificate
		//4 cert_QE = <pid, pub, $I, signature>
		//4
		//4 status = verify(signature, <pid, pub, $I>, pk(~isk))

		//cert_QE = <pid, pk(~ak), $IAS, signature>
		//5 cert_QE = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)>
		cert_QE = <$pid, pk(~ak), $IAS, signature>

		status = verify(signature, <$pid, pk(~ak), $IAS>, pk(~isk))
		//TODO com macros aqui como sig ou I sem dollar funciona?

		// Attestation Evidence Payload: *** only using `quote` ***
		//1 quote = <content, sign(content, ~ak), certificate>
		quote = <content, sig_QE, cert_QE>  // quote body || quote signature
		//6 quote = <content, sign(content, ~ak), cert_QE>  // quote body || quote signature
		aep = <quote, ~subscription_key>     // quote||manifest||nonce
		//3 aep = <content, sign(content, ~ak), cert_QE>

		// Attestation Verification Report
		//quote_status = verify(qs,qb,ipk)
		// quote_status, quote_body, etc in IAS spec... use correct names ??? TODO
		avr_data = <status, content>  // many fields, see IAS spec
		avr = <avr_data, sign(avr_data, ~rsk)>

		//aep = <content, sign(content, ~ak)>
		//aep = <content, sign(content, ~ak), certificate>
		//avr = <content, sign(content, rsk)>
	in
	[
		!IAS($IAS, ~isk, ~rsk, ~ltk, ~subscription_key),
		//523 !QE($pid, ~ak, cert, ~nonce),
		//In(aep)
		//In(<aep, '12345'>)
		//In(<senc(aep, ~subscription_key), '12345'>)
		//In(<aenc(~session_key, pk(~ltk)), senc(<$RAS, $I, aep, ~subscription_key>, ~session_key)>)
		//In(senc(aep,~subscription_key))

		In(aenc(<~server_session_key,~ssk2>, pk(~ltk))),
		In(senc(aep, ~server_session_key))
	]--[
		Progress_IAS(quote, ~server_session_key, avr, ~ssk2),

		//TODO
		Receive_IAS(<quote, ~subscription_key>),
		IAS_I1b($IAS, quote, ~subscription_key),//TORM
		//524 Send_IAS(avr),
		Send_IAS($IAS, avr),

		// Verify IAS signature over public key of QE
		Eq(true, status),

		// Verify QE signature over quote
		Eq(true, verify(sig_QE, content, pk(~ak))),
		//Eq(true, verify(sig_QE, content, pub)), // ou pub_QE

		//TODO
		Secret(~isk),
		Secret(~rsk)
	]->[
		//Out(avr)

		// Out(senc(avr, ~server_session_key))
		// Out(<$IAS,$RAS,senc(avr, ~server_session_key)>)
		Out(senc(avr, ~ssk2))
	]

//TODO payload coming from RAS needs to be changed from quote to aep

// rule RAS_1:
// 	let
// 		m7 = <quoteA,quoteB>
// 	in
// 	[
// 		In(m7)
// 	]--[
// 		RAS_I1(m7),
// 		RAS_O1(<quoteA>,<quoteB>)
// 	]->[
// 		Out(<quoteA>),  // m8a
// 		Out(<quoteB>)   // m8b
// 	]
//
//
// rule RAS_2:
// 	let
// 		m10 = <reportA,reportB>
// 	in
// 	[
// 		In(reportA),  // m9a
// 		In(reportB)   // m9b
// 	]--[
// 		RAS_I2(reportA,reportB),
// 		RAS_O2(m10)
// 	]->[
// 		Out(m10)
// 	]

// Consumes processing_4 and produces idle (placed in execution state, hence we say we're in state `idle`)
rule CAS_0:
	[
		// CAS(~tid, 'processing_4', data)
		CAS(~tid, 'processing_4', <$RAS, ~subscription_key, ~ltk>)
	]--[
		Progress_C0(~tid)
	]->[
		// CAS(~tid, 'idle', data)
		CAS(~tid, 'idle', <$RAS, ~subscription_key, ~ltk>)
	]

// Receive M13, Send M14
rule RAS_1:
	let
		// so = <~client_session_key, ~server_session_key, ~ssk2>
		so = <$RAS, ~subscription_key, ~ltk, ~client_session_key, ~server_session_key, ~ssk2>

		//pub = pk(~ltk_IAS)

		// cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)> // parte de baixo
		//TODO Não é necessário, apenas para ver se pattern funciona... problema do sig_QE no IAS
		//523 quote = <content, sign(content, ~ak), cert>
	in
	[
		// !RAS($RAS, ~subscription_key, ~ltk),
		CAS(~tid, 'idle', <$RAS, ~subscription_key, ~ltk>),

		!Pk($IAS, pub),                // retrieve server public key
		//In(quote),
		//In(aenc(quote, pk(~ltk))),
		In(aenc(~client_session_key, pk(~ltk))),
		In(senc(quote, ~client_session_key)),
		//In(<quote, '1111'>),
		Fr(~ssk2),
		Fr(~server_session_key)        // TLS session key
	]--[
		Progress_R1(quote, ~server_session_key),

		RAS_I1(quote),
		RAS_O1(<quote, ~subscription_key>),
		RAS_O1b($RAS, quote, ~subscription_key),//TORM
		Secret(~subscription_key)
	]->[
		// AgSt('RAS', $RAS, '1', so),
		CAS(~tid, 'processing_3', <$RAS, ~subscription_key, ~ltk, ~client_session_key, ~server_session_key, ~ssk2>),

		//0 Out(quote)
		//Out(<quote, '12345'>)
		//Out(<quote, CMAC(quote, ~subscription_key)>)
		// Sends session key encrypted with server public key, and
		// encrypted data (quote and subscription key) from RAS to IAS
		//1 Out(<aenc(~server_session_key, pub), senc(<$RAS, $IAS, quote, ~subscription_key>, ~server_session_key)>)
		//Out(senc(quote, ~subscription_key))
		//Out(<senc(quote, ~subscription_key), '12345'>)

		Out(aenc(<~server_session_key,~ssk2>, pub)),
		//Out(aenc(~ssk2, pub)),
		Out(senc(<quote, ~subscription_key>, ~server_session_key))
	]


rule RAS_2:
	let
		// si = <~client_session_key, ~server_session_key, ~ssk2>
		si = <$RAS, ~subscription_key, ~ltk, ~client_session_key, ~server_session_key, ~ssk2>

		so = <$RAS, ~subscription_key, ~ltk>
	in
	[
		// AgSt('RAS', $RAS, '1', si),
		// CAS(~tid, 'processing_3', si),
		CAS(~tid, 'processing_3', <$RAS, ~subscription_key, ~ltk, ~client_session_key, ~server_session_key, ~ssk2>),

		//1 Fr(~nonce),
		//524 In(report)

		// In(senc(avr, ~server_session_key))
		// In(<$IAS,$RAS,senc(avr, ~server_session_key)>)
		In(senc(avr, ~ssk2))
	]--[
		Progress_R2(avr, ~ssk2),

		//524 RAS_I2(avr),
		RAS_I2($RAS, avr)
		//, RAS_O2(avr)
	]->[
		// CAS(~tid, 'processing_4', so),
		CAS(~tid, 'processing_4', <$RAS, ~subscription_key, ~ltk>),

		//524 Out(report)
		////Out(senc(report, ~client_session_key))
		//1 Out(senc(<report>, ~client_session_key))
		Out(senc(avr, ~client_session_key))
	]

/******************************************************** */

restriction Equality:
	"All x y #i. Eq(x,y)@i ==> x=y"

restriction Inequality:
	"All x #i. Neq(x,x) @i ==> F"

restriction OnlyOnce:
	"All #i #j. OnlyOnce() @#i & OnlyOnce() @#j ==> #i = #j"

lemma secrecy:
	"All k #i #j. Secret(k) @i & K(k) @j ==> F"

lemma temp: exists-trace
	// "Ex m #i #j. RAS_O1(m) @i & Receive_IAS(m) @j & i<j"

	// "Ex RAS IAS m n #i #j. RAS_O1b(RAS,m,n) @i & IAS_I1b(IAS,m,n) @j"

	// "Ex RAS IAS m #i #j. Send_IAS(IAS,m) @i & RAS_I2(RAS,m) @j"

	"Ex A IAS m #i #j. Send_IAS(IAS,m) @i & Alice_I3(A,m) @j"

	// "Ex RAS IAS m n p #i #j #k #l.
	// 		RAS_O1b(RAS,m,n) @i & IAS_I1b(IAS,m,n) @j &
	// 		Send_IAS(IAS,p)@k & RAS_I2(RAS,p)@l &
	// 		i<j & j<k & k<l"

// Provar caminho IAS, RAS 2, Alice 3.
lemma temp_01: exists-trace
	"Ex A RAS IAS m #i #j #k. Send_IAS(IAS,m) @i & RAS_I2(RAS,m) @j & Alice_I3(A,m) @k"

// Provar caminho ...
lemma temp_02: exists-trace
	"
	Ex report quote ssk1 avr ssk2 tid #t20 #t21 #t22 #t23 #t24 #t25 #t26 #t27.
	Progress_A1(report) @ t20 & Progress_QE(report,quote) @ t21 & Progress_A2(quote) @ t22 & Progress_R1(quote,ssk1) @ t23 & Progress_IAS(quote,ssk1,avr,ssk2) @ t24 & Progress_R2(avr,ssk2) @ t25 & Progress_A3(avr) @ t26 &
	Progress_C0(tid) @ t27 &

	t20 < t21 &
	t21 < t22 &
	t22 < t23 &
	t23 < t24 &
	t24 < t25 &
	t25 < t26 &
	t26 < t27
	"
	//"Ex A RAS IAS m #i #j #k. Send_IAS(IAS,m) @i & RAS_I2(RAS,m) @j & Alice_I3(A,m) @k"

lemma temp_0: exists-trace
	"Ex Alice m #i #j. Alice_O2(Alice,m)@#i & RAS_I1(m)@#j & #i<#j"

// lemma temp_1: exists-trace
// 	"Ex Alice m n #i #j #k #l. Alice_O2(Alice,m)@#i & RAS_I1(m)@#j & #i<#j & RAS_O2(n)@#k & Alice_I3(Alice,n)@#l & k<l"
//
// lemma temp_2: exists-trace
// 	"Ex Alice n #k #l. RAS_O2(n)@#k & Alice_I3(Alice,n)@#l & k<l"

lemma temp_3: exists-trace
	"Ex A Q m #i #j. Alice_O1(A,m)@#i & Receive_QE(Q,m)@#j & i<j"

lemma detalhado: exists-trace
	"Ex A Q m1 m2 m3 #a #b #c #d #e #f.
	Alice_O1(A,m1)@a & Receive_QE(Q,m1)@b &
	Send_QE(Q,m2) @c & Alice_I2(A,m2) @d &
	Alice_O2(A,m3) @e & RAS_I1(m3) @f &
	a<b & b<c & c<d & d<e & e<f"

/**
** Prove that our protocol can be executed.
**
** Aggregates all previous functional lemmas in a single execution.
**/
lemma functional: exists-trace
	"
	(Ex A Q m #i #j. Alice_O1(A,m) @i & Receive_QE(Q,m) @j)
	&(Ex QE A m #i #j. Send_QE(QE,m) @i & Alice_I2(A,m) @j)
	&(Ex A m #i #j. Alice_O2(A, m) @i & RAS_I1(m) @j)
	&(Ex m #i #j. RAS_O1(m) @i & Receive_IAS(m) @j)
	//523 &(Ex m #i #j. Send_IAS(m) @i & RAS_I2(m) @j)
	//523 &(Ex A m #i #j. RAS_O2(m) @i & Alice_I3(A,m) @j)

	// (Ex A QE m1 m2 m3 m5 #i1 #j1 #i2 #j2 #i3 #j3 #i4 #j4 #i5 #j5 #i6 #j6.
	// 	Alice_O1(A,m1) @i1 & Receive_QE(QE,m1) @j1 &
	// 	Send_QE(QE,m2) @i2 & Alice_I2(A,m2) @j2 &
	// 	Alice_O2(A, m3) @i3 & RAS_I1(m3) @j3 &
	// 	RAS_O1(m3) @i4 & Receive_IAS(m3) @j4 &
	// 	Send_IAS(m5) @i5 & RAS_I2(m5) @j5 &
	// 	RAS_O2(m5) @i6 & Alice_I3(A,m5) @j6
	// 	& i1 < j1 & j1 < i2
	// 	& i2 < j2 & j2 < i3
	// 	& i3 < j3 & j3 < i4
	// 	& i4 < j4 & j4 < i5
	// 	& i5 < j5 & j5 < i6
	// 	& i6 < j6
	// 	& i1 < i3 & i3 < j6)

	// &(Ex C Q m #i #j. Carol_O1(C,m) @i & Receive_QE(Q,m) @j)
	// &(Ex QE C m #i #j. Send_QE(QE,m) @i & Carol_I2(C,m) @j)
	// &(Ex C m #i #j. Carol_O2(C, m) @i & RAS_I1(m) @j)
	// &(Ex m #i #j. RAS_O1(m) @i & Receive_IAS(m) @j)
	// &(Ex m #i #j. Send_IAS(m) @i & RAS_I2(m) @j)
	// &(Ex C m #i #j. RAS_O2(m) @i & Carol_I3(C,m) @j)
	//
	// &(Ex D Q m #i #j. Dalia_O1(D,m) @i & Receive_QE(Q,m) @j)
	// &(Ex QE D m #i #j. Send_QE(QE,m) @i & Dalia_I2(D,m) @j)
	// &(Ex D m #i #j. Dalia_O2(D, m) @i & RAS_I1(m) @j)
	// &(Ex m #i #j. RAS_O1(m) @i & Receive_IAS(m) @j)
	// &(Ex m #i #j. Send_IAS(m) @i & RAS_I2(m) @j)
	// &(Ex D m #i #j. RAS_O2(m) @i & Dalia_I3(D,m) @j)


	// (Ex A B m #i #j. Alice_O1(A,m) @i & Boris_I1(B,m) @j)
	// &(Ex B QE m #i #j. Boris_O1(B,m) @i & Receive_QE(QE,m) @j)
	// &(Ex QE B m #i #j. Send_QE(QE,m) @i & Boris_I2(B,m) @j)
	// &(Ex B A m #i #j. Boris_O2(B,m) @i & Alice_I2(A,m) @j)
	// &(Ex A QE m #i #j. Alice_O2(A,m) @i & Receive_QE(QE,m) @j)
	// &(Ex QE A m #i #j. Send_QE(QE,m) @i & Alice_I3(A,m) @j)
	// &(Ex A m #i #j. Alice_O3(A,m) @i & RAS_I1(m) @j)
	// &(Ex m n #i #j #k. RAS_O1(m,n) @i & Receive_IAS(m) @j & Receive_IAS(n) @k)
	// &(Ex m n #i #j #k. Send_IAS(m) @i & Send_IAS(n) @j & RAS_I2(m,n) @k)
	// &(Ex A m #i #j. RAS_O2(m) @i & Alice_I4(A,m) @j)
	// &(Ex A B m #i #j. Alice_O4(A,m) @i & Boris_I3(B,m) @j)
	"

end
