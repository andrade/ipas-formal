/**
** Protocol: AS v3
** Author:   Daniel Andrade
** Date:     03/2021
** Status:   WIP
**/

theory ASv3
begin

builtins: hashing, signing, diffie-hellman

functions:
	CMAC/2,                  // RFC 4493
	SHA/1,
	real/1 [private],
	sgx_get_key/1

rule Create_IAS:
	[
		Fr(~id_IAS),
		Fr(~priv_IAS)
	]--[
		OnlyOnce(),
		Create_IAS(~id_IAS)
	]->[
		// !ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS), // root keys, we use single key pair
		Out(~id_IAS)
	]

rule Create_QE:
	[ Fr(~id_QE) ]--[ Create_QE(~id_QE) ]->[ ID_QE(~id_QE), Out(~id_QE) ]

rule Create_Enclave:
	[
		Fr(~id_Enclave),
		Fr(~MRENCLAVE),
		Fr(~MRSIGNER)
	]--[
		Create_Enclave(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]->[
		ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		Out(~id_Enclave),
		Out(~MRENCLAVE),
		Out(~MRSIGNER)
	]

rule Create_CPU:
	[
		Fr(~id_CPU)
	]--[
		Create_CPU(~id_CPU)
	]->[
		ID_CPU(~id_CPU),
		Out(~id_CPU)
	]

// Provision CPU and QE: essentially registers these two agents with Intel
rule Provisioning:
	[
		// !ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		ID_QE(~id_QE),
		ID_CPU(~id_CPU),
		Fr(~tid_QE),
		Fr(~priv_QE), // attestation key for QE, uses to sign quotes
		Fr(~tid_CPU)
	]--[
		Provision(~id_QE, ~id_CPU, ~id_IAS, ~tid_QE, ~tid_CPU)
	]->[
		!State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		!State_CPU(~tid_CPU, 'Provisioning_CPU', <~id_CPU, ~tid_QE, ~id_QE, ~id_IAS, sign(~id_CPU, ~priv_IAS), pk(~priv_IAS)>)
	]

// Whitelist enclave
rule Licensing:
	let
		// Enclave ID, IAS ID, IAS signature over Enclave ID, IAS public key
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]--[
		Licensing(~id_Enclave, ~id_IAS)
	]->[
		!License(~id_Enclave, license)
	]

// Bind enclave to CPU: results in instance of this enclave running on this CPU
rule Binding:
	[
		!State_CPU(~tid_CPU, 'Provisioning_CPU', <~id_CPU, ~tid_QE, ~id_QE, ~id_IAS, sign(~id_CPU, ~priv_IAS), pk(~priv_IAS)>),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		Fr(~tid_Enclave)
		// isto acaba por ser Thread ID de instância do enclave
		// TODO mod para fresh ~tid_Instance
	]--[
		Binding(~tid_Enclave, ~id_Enclave, ~id_CPU, ~tid_CPU)
	]->[
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~tid_CPU, ~id_CPU>)
	]

/*rule Frank_1 [color=F5CBA7]:
let
	report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

	data = <~hF>
	body = <$F, ~id_CPU, ~MRENCLAVE, data>
	report = <body, CMAC(body, report_key)>

	so = <~hF>
in
[
	!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
	!License(~id_Enclave, license),
	State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~tid_CPU, ~id_CPU>),
	Fr(~hF)
]--[
	Progress_F1(~tid_Enclave, ~tid_CPU, $F, ~hF, report)
]->[
	State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~tid_CPU, ~id_CPU>),
	AgSt('enclave', $F, '1', so),
	Out(report)
]

rule Frank_2 [color=F5CBA7]:
let
	si = <~hF>
	so = <~hF>

	quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sig_IAS>
in
[
	AgSt('enclave', $F, '1', si),
	State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~tid_CPU, ~id_CPU>),
	In(quote)
]--[
	Progress_F2(~tid_Enclave, ~tid_CPU, $F, ~hF, quote)
]->[
	State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~tid_CPU, ~id_CPU>),
	AgSt('enclave', $F, '2', so),
	Out(quote)
]

rule Frank_3 [color=F5CBA7]:
let
	si = <~hF>

	license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pub_IAS>

	data = <~hF>
	body = <$F, ~id_CPU, ~MRENCLAVE, data>
	content = <body>
	report = <content, signature>
in
[
	AgSt('enclave', $F, '2', si),
	State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~tid_CPU, ~id_CPU>),
	!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
	!License(~id_Enclave, license),
	In(report)
]--[
	Progress_F3(~tid_Enclave, ~tid_CPU, $F, ~hF, report),
	Eq(true, verify(signature, content, pub_IAS))
]->[
]*/

rule DH [color=F4D03F]:
	[ Fr(~k) ]-->[ !DH_private($id, ~k), !DH_public($id, 'g'^~k), Out('g'^~k) ]

rule Reveal_DH:
	[ !DH_private(id, k) ]--[ Leak_private_DH(id) ]->[ Out(k) ]

// rule Register_pk:
// 	[ Fr(~ltk) ]-->[ !Ltk($id, ~ltk), !Pk($id, pk(~ltk)) ]
//
// rule Get_pk:
// 	[ !Pk(id, pub) ]-->[ Out(pub) ]
//
// rule Reveal_ltk:
// 	[ !Ltk(id, ltk) ]--[ Reveal(id) ]->[ Out(ltk) ]

rule Connect:
	[
		State_Enclave(~tid_E1, 'bound', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1>),
		State_Enclave(~tid_E2, 'bound', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2>)
	]--[
		Connected(~tid_E1, ~tid_E2)
	]->[
		State_Enclave(~tid_E1, 'connected', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, ~tid_E2>),
		State_Enclave(~tid_E2, 'connected', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2, ~tid_E1>),

		Out(~tid_E1),
		Out(~tid_E2)
	]

rule A1 [color=D7BDE2]:
	let
		m7 = <~ANonce, APublic>
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Alice, 'connected', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, ~tid_Boris>),
		Fr(~ANonce),
		!DH_private($A, ~APrivate),
		!DH_public($A, APublic)
	]--[
		Progress_A1(~tid_Alice, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m7)
	]->[
		State_Enclave(~tid_Alice, 'TODO', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, ~tid_Boris>),
		Out(m7)
	]

rule B2 [color=D2B4DE]:
	let
		m7 = <~ANonce, APublic>

		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU_2)>)

		// data = h(<APublic, BPublic, VK>)
		// REVIEW Utilizo os nonces em vez de VK
		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
		body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		m8 = report
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Boris, 'connected', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2, ~tid_Alice>),
		Fr(~BNonce),
		!DH_private($B, ~BPrivate),
		!DH_public($B, BPublic),
		In(m7)
	]--[
		Progress_B2(~tid_Boris, ~tid_Alice, ~tid_CPU_2, $B, ~id_Enclave, ~id_CPU_2, m7, m8)
	]->[
		State_Enclave(~tid_Boris, 'LA', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2, $B, ~BNonce, ~BPrivate, BPublic, ~tid_Alice, ~ANonce, APublic>),
		Out(m8)
	]

rule B3 [color=D2B4DE]:
	let
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
		body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
		m9 = quote

		m10 = <~BNonce, BPublic, quote>
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Boris, 'LA', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2, $B, ~BNonce, ~BPrivate, BPublic, ~tid_Alice, ~ANonce, APublic>),
		In(m9)
	]--[
		Progress_B3(~tid_Boris, ~tid_Alice, ~tid_CPU_2, $B, ~id_Enclave, ~id_CPU_2, m9, m10)
	]->[
		State_Enclave(~tid_Boris, 'TODO', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2, $B, ~BNonce, ~BPrivate, BPublic, quote, ~tid_Alice, ~ANonce, APublic>),
		Out(m10)
	]

rule A4 [color=D7BDE2]:
	let
		m10 = <~BNonce, BPublic, BQuote>

		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU_1)>)

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
		body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		m11 = report
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Alice, 'TODO', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, ~tid_Boris>),
		// !DH_public($A, APublic),
		In(m10)
	]--[
		Progress_A4(~tid_Alice, ~tid_Boris, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m10, m11)
	]->[
		State_Enclave(~tid_Alice, 'LA', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, ~tid_Boris, ~BNonce, BPublic, BQuote>),
		Out(m11)
	]

rule A5 [color=D7BDE2]:
	let
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)
		body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
		m12 = AQuote

		m13a = AQuote
		m13b = BQuote
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Alice, 'LA', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, ~tid_Boris, ~BNonce, BPublic, BQuote>),
		// !DH_public($A, APublic),
		// !DH_public($B, BPublic),
		In(m12)
	]--[
		Progress_A5(~tid_Alice, ~tid_Boris, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m12, m13a, m13b)
	]->[
		State_Enclave(~tid_Alice, 'RA', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, AQuote, ~tid_Boris, ~BNonce, BPublic, BQuote>),
		Out(m13a),
		Out(m13b)
	]

rule A6 [color=D7BDE2]:
	let
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pub_IAS>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)

		AReport_body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		AReport_content = <AReport_body>
		AReport = <AReport_content, sign(AReport_content, ~priv_IAS)>
		m16a = AReport

		BReport_body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		BReport_content = <BReport_body>
		BReport = <BReport_content, sign(BReport_content, ~priv_IAS)>
		m16b = BReport

		m17 = <AReport, BReport>
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Alice, 'RA', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, AQuote, ~tid_Boris, ~BNonce, BPublic, BQuote>),
		// !DH_public($A, APublic),
		// !DH_public($B, BPublic),
		In(m16a),
		In(m16b)
	]--[
		Progress_A6(~tid_Alice, ~tid_Boris, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m16a, m16b, m17),

		Eq(true, verify(sign(AReport_content, ~priv_IAS), AReport_content, pub_IAS)),

		Eq(true, verify(sign(BReport_content, ~priv_IAS), BReport_content, pub_IAS))
	]->[
		State_Enclave(~tid_Alice, 'installing', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, AQuote, ~tid_Boris, ~BNonce, BPublic, BQuote, AReport, BReport>),
		Out(m17)
	]

rule B4 [color=D2B4DE]:
	let
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pub_IAS>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)

		AReport_body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		AReport_content = <AReport_body>
		AReport = <AReport_content, sign(AReport_content, ~priv_IAS)>
		m16a = AReport

		BReport_body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		BReport_content = <BReport_body>
		BReport = <BReport_content, sign(BReport_content, ~priv_IAS)>

		m17 = <AReport, BReport>

		KDK = APublic^~BPrivate
		MK = CMAC('MK', KDK)
		SK = CMAC('SK', KDK)

		m18 = 'OK'
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Boris, 'TODO', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2, $B, ~BNonce, ~BPrivate, BPublic, BQuote, ~tid_Alice, ~ANonce, APublic>),
		// !DH_public($A, APublic),
		// !DH_public($B, BPublic),
		In(m17)
	]--[
		SessionKeys($A, $B, MK, SK),
		Progress_B4(~tid_Boris, ~tid_Alice, ~tid_CPU_2, $B, ~id_Enclave, ~id_CPU_2, m17, m18, MK, SK, ~BPrivate),

		Eq(true, verify(sign(AReport_content, ~priv_IAS), AReport_content, pub_IAS)),

		Eq(true, verify(sign(BReport_content, ~priv_IAS), BReport_content, pub_IAS))
	]->[
		// Não faz sentido ter?
		// State_Enclave(~tid_Boris, 'done', <~id_Enclave, ~tid_CPU_2, ~id_CPU_2, ~tid_Alice, MK, SK>),
		Out(m18)
	]

rule A7 [color=D7BDE2]:
	let
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pub_IAS>

		data = h(<APublic, BPublic, ~ANonce, ~BNonce>)

		AReport_body = <$A, ~id_CPU_1, ~MRENCLAVE, data>
		AReport_content = <AReport_body>
		AReport = <AReport_content, sign(AReport_content, ~priv_IAS)>

		BReport_body = <$B, ~id_CPU_2, ~MRENCLAVE, data>
		BReport_content = <BReport_body>
		BReport = <BReport_content, sign(BReport_content, ~priv_IAS)>

		m18 = 'OK'

		KDK = BPublic^~APrivate
		MK = CMAC('MK', KDK)
		SK = CMAC('SK', KDK)
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Alice, 'installing', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, $A, ~ANonce, ~APrivate, APublic, AQuote, ~tid_Boris, ~BNonce, BPublic, BQuote, AReport, BReport>),
		// !DH_public($A, APublic),
		// !DH_public($B, BPublic),
		In(m18)
	]--[
		SessionKeys($A, $B, MK, SK),
		Progress_A7(~tid_Alice, ~tid_Boris, ~tid_CPU_1, $A, ~id_Enclave, ~id_CPU_1, m18, MK, SK, ~APrivate),

		Eq(true, verify(sign(AReport_content, ~priv_IAS), AReport_content, pub_IAS)),

		Eq(true, verify(sign(BReport_content, ~priv_IAS), BReport_content, pub_IAS))
	]->[
		// Não faz sentido ter?
		// State_Enclave(~tid_Alice, 'done', <~id_Enclave, ~tid_CPU_1, ~id_CPU_1, ~tid_Boris, MK, SK>)
	]

/**
** The Quoting Enclave receives a report from an enclave, and
** produces a certified (signed by AK) quote for that enclave.
**/
rule QE [color=AADADA]:
let
	report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

	// TEMP não funciona para Frank, etc. Apenas para testar com session_keys
	// data = h(<APublic, BPublic, ~ANonce, ~BNonce>)

	// 5.15: Este body não devia interessar, desde que CMAC correto.
	// 5.15: body = <$F, ~id_CPU, ~MRENCLAVE, data>
	report = <body, CMAC(body, report_key)>
	content = <body>
	quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
in
[
	!State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
	In(report)
]--[
	Progress_QE(~tid_QE, ~tid_CPU, report, quote)
]->[
	// State_QE(~tid_QE, 'done', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
	Out(quote)
]

rule IAS [color=DADADA]:
let
	body = <$F, ~id_CPU, ~MRENCLAVE, data>
	content = <body>
	quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>

	report = <content, sign(content, ~priv_IAS)>
in
[
	// !ID_IAS(~id_IAS),
	!Keys_IAS(~id_IAS, ~priv_IAS),
	In(quote)
]--[
	Progress_IAS(~id_IAS, quote, report),

	// verify IAS signature over public key of QE
	Eq(true, verify(sign(pk(~priv_QE), ~priv_IAS), pk(~priv_QE), pk(~priv_IAS))),

	// verify QE signature over contents of quote
	Eq(true, verify(sign(content, ~priv_QE), content, pk(~priv_QE)))
]->[
	Out(report)
]



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



restriction Equality:
	"All x y #i. Eq(x,y)@i ==> x=y"

// restriction Inequality:
// 	"All x #i. Neq(x,x) @i ==> F"

restriction OnlyOnce:
	"All #i #j. OnlyOnce() @#i & OnlyOnce() @#j ==> #i = #j"

// lemma secrecy:
// 	"All k #i #j. Secret(k) @i & K(k) @j ==> F"

// E1 e E2 são o mesmo enclave mas a executar em processadores diferentes: E1 no CPU_1, e E2 e E3 no CPU_3.
/*lemma Multi: exists-trace
	"
	Ex
		id_CPU_1 tid_CPU_1 MRENCLAVE_1 MRSIGNER_1 id_QE_1 tid_QE_1
		id_CPU_3 tid_CPU_3 MRENCLAVE_3 MRSIGNER_3 id_QE_3 tid_QE_3
		E1 tid_E1 X h1 r1 q1 a1
		E2 tid_E2 Y h2 r2 q2 a2
		E3 tid_E3 Z h3 r3 q3 a3
		id_IAS
	#s11 #s12 #s13 #s14 #s15 #s16 #s17 #s18
	#s21 #s22 #s23 #s24 #s25 #s26 #s27 #s28
	#t1 #t2 #t3 #t4 #t5 #t6 #t7 #t8 #t9 #t10 #t11 #t12 #t13 #t14 #t15.

	not(id_CPU_1=id_CPU_3) &
	not(id_QE_1=id_QE_3) &
	E1=E2 & not(E2=E3) & // E1, E2 são mesmo enclave
	not(tid_E1=tid_E2) & // mas com instâncias diferentes
	not(tid_E2=tid_E3) &
	not(MRENCLAVE_1=MRENCLAVE_3) &
	not(MRSIGNER_1=MRSIGNER_3) &

	Create_IAS(id_IAS) @ s11 &
	Create_QE(id_QE_1) @ s12 &
	Create_QE(id_QE_3) @ s13 &
	Create_CPU(id_CPU_1) @ s14 &
	Create_CPU(id_CPU_3) @ s15 &
	Create_Enclave(E1, MRENCLAVE_1, MRSIGNER_1) @ s16 &
	Create_Enclave(E2, MRENCLAVE_1, MRSIGNER_1) @ s17 &
	Create_Enclave(E3, MRENCLAVE_3, MRSIGNER_3) @ s18 &

	Provision(id_QE_1, id_CPU_1, id_IAS, tid_QE_1, tid_CPU_1) @ s21 &
	Provision(id_QE_3, id_CPU_3, id_IAS, tid_QE_3, tid_CPU_3) @ s22 &
	Licensing(E1, id_IAS) @ s23 &
	Licensing(E2, id_IAS) @ s24 &
	Licensing(E3, id_IAS) @ s25 &
	Binding(tid_E1, E1, id_CPU_1, tid_CPU_1) @ s26 &
	Binding(tid_E2, E2, id_CPU_3, tid_CPU_3) @ s27 &
	Binding(tid_E3, E3, id_CPU_3, tid_CPU_3) @ s28 &

	Progress_F1(tid_E1, tid_CPU_1, X, h1, r1) @ t1 &
	Progress_F1(tid_E2, tid_CPU_3, Y, h2, r2) @ t2 &
	Progress_F1(tid_E3, tid_CPU_3, Z, h3, r3) @ t3 &
	Progress_QE(tid_QE_1, tid_CPU_1, r1, q1) @ t4 &
	Progress_QE(tid_QE_3, tid_CPU_3, r2, q2) @ t5 &
	Progress_QE(tid_QE_3, tid_CPU_3, r3, q3) @ t6 &
	Progress_F2(tid_E1, tid_CPU_1, X, h1, q1) @ t7 &
	Progress_F2(tid_E2, tid_CPU_3, Y, h2, q2) @ t8 &
	Progress_F2(tid_E3, tid_CPU_3, Z, h3, q3) @ t9 &
	Progress_IAS(id_IAS, q1, a1) @ t10 &
	Progress_IAS(id_IAS, q2, a2) @ t11 &
	Progress_IAS(id_IAS, q3, a3) @ t12 &
	Progress_F3(tid_E1, tid_CPU_1, X, h1, a1) @ t13 &
	Progress_F3(tid_E2, tid_CPU_3, Y, h2, a2) @ t14 &
	Progress_F3(tid_E3, tid_CPU_3, Z, h3, a3) @ t15
	"

lemma Frank: exists-trace
	"
	Ex
		id_IAS id_QE id_CPU id_Enclave MRENCLAVE MRSIGNER
		tid_CPU tid_QE
		tid_Enclave report quote reply
		F hF
	#s1 #s3 #s4 #s5 #s6 #s7 #s8
	#t1 #t2 #t3 #t5 #t7.

	not(id_IAS=id_QE) & not(id_IAS=id_CPU) & not(id_IAS=id_Enclave) & not(id_QE=id_CPU) & not(id_QE=id_Enclave) & not(id_CPU=id_Enclave) &

	not(report=quote) & not(report=reply) & not(quote=reply) &

	Create_IAS(id_IAS) @ s1 &
	Create_QE(id_QE) @ s3 &
	Create_CPU(id_CPU) @ s4 &
	Create_Enclave(id_Enclave, MRENCLAVE, MRSIGNER) @ s5 &

	Provision(id_QE, id_CPU, id_IAS, tid_QE, tid_CPU) @ s6 &
	Licensing(id_Enclave, id_IAS) @ s7 &
	Binding(tid_Enclave, id_Enclave, id_CPU, tid_CPU) @ s8 &

	Progress_F1(tid_Enclave, tid_CPU, F, hF, report) @ t1 &
	Progress_QE(tid_QE, tid_CPU, report, quote) @ t2 &
	Progress_F2(tid_Enclave, tid_CPU, F, hF, quote) @ t3 &
	Progress_IAS(id_IAS, quote, reply) @ t5 &
	Progress_F3(tid_Enclave, tid_CPU, F, hF, reply) @ t7 &

	s8 < t1 & // binding antes de Frank 1

	s6 < t2 & // provisioning antes de QE

	t1 < t2 & t2 < t3 & t3 < t5 & t5 < t7
	"*/

// WIP: Alice and Boris
lemma temp_one: exists-trace
	"
	Ex
		A tid_Alice id_CPU_1
		B tid_Boris id_CPU_2
		id_Enclave MRENCLAVE MRSIGNER
		id_QE_1 id_QE_2 tid_QE_1 tid_QE_2 tid_CPU_1 tid_CPU_2
		id_IAS
		MK SK APrivate BPrivate
		m7 m8 m9 m10 m11 m12 m13a m13b m16a m16b m17 m18
	#s1 #s2 #s3 #s4 #s5 #s6
	#s11 #s12 #s13 #s15 #s16 #s17
	#t11 #t14 #t15 #t16 #t17
	#t22 #t23 #t24
	#t51 #t52
	#t71 #t72.

	not( APrivate = BPrivate ) &

	Create_IAS(id_IAS) @ s1 &
	Create_CPU(id_CPU_1) @ s2 &
	Create_CPU(id_CPU_2) @ s3 &
	Create_QE(id_QE_1) @ s4 &
	Create_QE(id_QE_2) @ s5 &
	Create_Enclave(id_Enclave, MRENCLAVE, MRSIGNER) @ s6 &

	Provision(id_QE_1, id_CPU_1, id_IAS, tid_QE_1, tid_CPU_1) @ s11 &
	Provision(id_QE_2, id_CPU_2, id_IAS, tid_QE_2, tid_CPU_2) @ s12 &
	Licensing(id_Enclave, id_IAS) @ s13 &
	Binding(tid_Alice, id_Enclave, id_CPU_1, tid_CPU_1) @ s15 &
	Binding(tid_Boris, id_Enclave, id_CPU_2, tid_CPU_2) @ s16 &

	Connected(tid_Alice, tid_Boris) @ s17 &

	Progress_A1(tid_Alice, tid_CPU_1, A, id_Enclave, id_CPU_1, m7) @ t11 &
	Progress_B2(tid_Boris, tid_Alice, tid_CPU_2, B, id_Enclave, id_CPU_2, m7, m8) @ t22 &
	Progress_QE(tid_QE_2, tid_CPU_2, m8, m9) @ t51 &
	Progress_B3(tid_Boris, tid_Alice, tid_CPU_2, B, id_Enclave, id_CPU_2, m9, m10) @ t23 &
	Progress_A4(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m10, m11) @ t14 &
	Progress_QE(tid_QE_1, tid_CPU_1, m11, m12) @ t52 &
	Progress_A5(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m12, m13a, m13b) @ t15 &
	Progress_IAS(id_IAS, m13a, m16a) @ t71 &
	Progress_IAS(id_IAS, m13b, m16b) @ t72 &
	Progress_A6(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m16a, m16b, m17) @ t16 &
	Progress_B4(tid_Boris, tid_Alice, tid_CPU_2, B, id_Enclave, id_CPU_2, m17, m18, MK, SK, BPrivate) @ t24 &
	Progress_A7(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m18, MK, SK, APrivate) @ t17 &

	t11 < t22 & t22 < t51 & t51 < t23 & t23 < t14 & t14 < t52 & t52 < t15 &
	t15 < t71 & t15 < t72 & t71 < t16 & t72 < t16 & t16 < t24 & t24 < t17
	"

/**
** Ensure session keys can be setup between honest agents.
**
** There is a trace where all equality checks are satisfied and
** session keys MK, SK are setup without revealing private DH keys.
**/
lemma session_keys: exists-trace
	"
		(All x y #i. Eq(x,y)@i ==> x=y) &
		(Ex A B MK SK #k.
			SessionKeys(A, B, MK, SK) @ k &
			not(Ex #r. Leak_private_DH(A) @ r) &
			not(Ex #r. Leak_private_DH(B) @ r)
		)
	"

lemma session_keys_secrecy:
	"not(
		Ex A B MK SK #k.
			SessionKeys(A, B, MK, SK) @k &
			((Ex #i. K(MK) @i) | (Ex #i. K(SK) @i)) &
			not(Ex #r. Leak_private_DH(A) @ r) &
			not(Ex #r. Leak_private_DH(B) @ r)
	)
	"

lemma honest_keys: exists-trace
	"Ex
		A tid_Alice id_CPU_1 tid_CPU_1
		B tid_Boris id_CPU_2 tid_CPU_2
		id_Enclave
		m1 m2
		MK SK APrivate BPrivate
	#t1 #t2.

	not(APrivate=BPrivate) &

	Progress_B4(tid_Boris, tid_Alice, tid_CPU_2, B, id_Enclave, id_CPU_2, m1, m2, MK, SK, BPrivate) @ t1 &
	Progress_A7(tid_Alice, tid_Boris, tid_CPU_1, A, id_Enclave, id_CPU_1, m2, MK, SK, APrivate) @ t2 &

	t1 < t2
	"

end
