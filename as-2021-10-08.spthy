/**
** Protocol: AS v3
** Author:   Daniel Andrade
** Date:     03/2021
** Status:   WIP
**/

theory ASv3_no_CAS
begin

builtins: hashing, signing, diffie-hellman
builtins: asymmetric-encryption, symmetric-encryption

functions:
	MAC/2,
	CMAC/2,                  // RFC 4493
	SHA/1,
	// transport_key/3 [private], // source, destination, session nonce // rat
	//isk/0 [private],         // Intel Signing Key
	//rsk/0 [private],         // Report Signing Key
	real/1 [private],
	sgx_get_key/1
	//sgx_get_key/1 [private]  //TODO Why this doesn't work?

// rule Reveal:
// 	[In(a),In(b),In(n)]--[Reveal()]->[Out(transport_key(a,b,n))]

rule Create_IAS:
	[
		Fr(~id_IAS),
		Fr(~priv_IAS)
	]--[
		OnlyOnce(),
		Create_IAS(~id_IAS)
	]->[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS), // root keys, we use single key pair
		Out(~id_IAS)
	]

// rule Create_CAS:
// 	[ Fr(~id_CAS) ]--[ Create_CAS(~id_CAS) ]->[ !ID_CAS(~id_CAS), Out(~id_CAS) ]

rule Create_RAS:
	[ Fr(~id_RAS) ]--[ Create_RAS(~id_RAS) ]->[ !ID_RAS(~id_RAS), Out(~id_RAS) ]

rule Create_QE:
	[ Fr(~id_QE) ]--[ Create_QE(~id_QE) ]->[ !ID_QE(~id_QE), Out(~id_QE) ]

rule Create_Enclave:
	[
		Fr(~id_Enclave),
		Fr(~MRENCLAVE),
		Fr(~MRSIGNER)
	]--[
		Create_Enclave(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]->[
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		Out(~id_Enclave),
		Out(~MRENCLAVE),
		Out(~MRSIGNER)
	]

rule Create_CPU:
	[
		Fr(~id_CPU)
	]--[
		Create_CPU(~id_CPU)
	]->[
		!ID_CPU(~id_CPU),
		Out(~id_CPU)
	]

// Provision CPU and QE: essentially registers these two agents with Intel
rule Provisioning:
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		!ID_QE(~id_QE),
		!ID_CPU(~id_CPU),
		Fr(~tid_QE),
		Fr(~priv_QE), // attestation key for QE, uses to sign quotes
		Fr(~tid_CPU)
	]--[
		Provision(~id_QE, ~id_CPU, ~id_IAS, ~tid_QE, ~tid_CPU)
	]->[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		State_CPU(~tid_CPU, 'Provisioning_CPU', <~id_CPU, ~tid_QE, ~id_QE, ~id_IAS, sign(~id_CPU, ~priv_IAS), pk(~priv_IAS)>)
	]

// Whitelist enclave
rule Licensing:
	let
		// Enclave ID, IAS ID, IAS signature over Enclave ID, IAS public key
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]--[
		Licensing(~id_Enclave, ~id_IAS)
	]->[
		!License(~id_Enclave, license)
	]

// Bind enclave to CPU
// FIXME: Enclave deve ter lá os MR ?? TODO: acho que sim para poder fork igual
rule Binding:
	[
		!ID_CPU(~id_CPU),
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		Fr(~tid_Enclave)
	]--[
		Binding(~tid_Enclave, ~id_Enclave, ~id_CPU)
	]->[
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~id_CPU>)
	]

// TODO Acho que teremos N RAS para N QE, como modelar isto, onde crio tid_IAS que aparece também em Register_QE? (possivelmente num local e depois input do estado para o outro?)
// TODO Talvez mudar nome para associate em vez de register? E é preciso a key!
// rule Register_CAS:
// 	[
// 		!ID_IAS(~id_IAS),
// 		!ID_CAS(~id_CAS),
// 		Fr(~tid_IAS),
// 		Fr(~tid_CAS),
// 		Fr(~subscription_key)
// 	]--[
// 		Register_CAS(~id_CAS, ~id_IAS, ~tid_CAS, ~tid_IAS)
// 	]->[
// 		State_CAS(~tid_CAS, 'idle', <~id_CAS, ~tid_IAS, ~subscription_key>),
// 		State_IAS(~tid_IAS, 'idle', <~id_IAS, ~tid_CAS, ~subscription_key>)
// 	]



rule Frank_1:
	let
		// report_key = sgx_get_key(<~MRENCLAVE, 'report', ~nonce>)
		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

		// TODO Usar `real(id_CPU)` ou coisa parecida?
		// Posso depois experimentar ter isto num create, e fazer create desse agente (placeholder) falso para ver se adversário consegue invocar regra mas sem a função...

		data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		so = <~hF>
	in
	[
		//TODO O que utilizar como C e p ? Os IDs de CPU e enclave? Repensar!
		// !Enclave($C, $p, $MRENCLAVE, $MRSIGNER, ~nonce)
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~id_CPU>),
		Fr(~hF)
	]--[
		Progress_F1(~tid_Enclave, $F, '1', ~hF, report)
	]->[
		State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~id_CPU>),
		AgSt('enclave', $F, '1', so),
		Out(report)
	]

rule Frank_2:
	let
		si = <~hF>
		so = <~hF>

		// cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)> // parte de baixo
		//TODO Não é necessário, apenas para ver se pattern funciona... problema do sig_QE no IAS
		//523 quote = <content, sign(content, ~ak), cert>

		//TEMP: desnecessário:
		// quote = <content, sign(content, ~ak), cert>
		//FIXME check this okay **** 11
		//TEMP 9.21: quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
		// NOTE Frank 2 não tem IAS pub key! Portanto acima não funcionaria: wrong ???
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sig_IAS>
	in
	[
		AgSt('enclave', $F, '1', si),
		State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~id_CPU>),
		// !Enclave($C, $p, $MRENCLAVE, $MRSIGNER, ~nonce),
		// !Pk($RAS, pub),
		// Fr(~session_key),
		In(quote)
	]--[
		Progress_F2(~tid_Enclave, $F, '1', '2', ~hF, quote)
	]->[
		AgSt('enclave', $F, '2', so),
		State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~id_CPU>),
		Out(quote)
		//TODO quote tem thread ID? E enviar através de túnel TLS? (enviar fora de túnel OK sinigifca que mais robusto do que com túnel, portanto assumption stronger in model)
		// Out(aenc(~session_key, pub)),
		// Out(senc(quote, ~session_key))
	]

//[color=DAAADA]
rule Frank_3:
	let
		si = <~hF>
		// // uid = <$prog,$eidA,$pidA>
		// m7 = <qA,qB>

		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>

		data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		//
		content = <body>
		// avr_data = <'OK', content>
		// //certified_report = <avr_data, sign(avr_data, rsk)>
		// // certified_report = <avr_data, signature>
		// avr = <avr_data, sign(avr_data, ~priv_IAS)>

		report = <content, sign(content, ~priv_IAS)>
	in
	[
		AgSt('enclave', $F, '2', si),
		State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~id_CPU>),
		// !IAS_pub($IAS, pk(~rsk)), // assume IAS public key hardcoded
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		// In(avr)
		// // In(senc(certified_report, ~session_key))
		In(report)
	]--[
		Progress_F3(~tid_Enclave, $F, '2', ~hF, report)
		// Eq(true, verify(signature, avr_data, pk(~rsk)))
	]->[
	]



//REVIEW
/**
** The Quoting Enclave receives a report from an enclave, and
** produces a certified (signed by AK) quote for that enclave.
** The quote normally contains enclave measurement, etc, but in
** this case we only sign over the enclave identity (can be expanded).
**
** Receives local attestation from E (via A), and produces a quote.
**/
rule QE_new [color=AADADA]:
	let
		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

		// cert = <$pid, pk(~ak), $IAS, sign(<$pid, pk(~ak), $IAS>, ~isk)>
		// //NOTE Não é necessário estar aqui, mas ver se assim termina
		// //TODO remove

		// data = <'hA'>
		// Remover para suportar múltiplos enclaves TODO
		// body = <$eid, $pid, $MRENCLAVE, data>
		// report = <body, CMAC(body, report_key)>
		// data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
		// FIXME Não é preciso aqui chave pública do QE para que Intel consiga verificar a assinatura do QE sobre o 'content'? FIXED: adicionei pub QE
	in
	[
		// !QE($pid, ~ak, cert, ~nonce),
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		// !IAS_pub($IAS, pk(~isk)), //TODO remove //NOTE Isto causava problemas e tinha estado falsificado, mas ao comentar já funciona... provavelmente isto iniciava também setup antigo e criava conflitos!
		In(report)
	]--[
		Progress_QE_new_1(~tid_QE, ~tid_CPU, report, quote)
	]->[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		Out(quote)
	]

rule IAS_new [color=DADADA]:
	let
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>

		report = <content, sign(content, ~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		In(quote)
	]--[
		Progress_IAS(~id_IAS, quote, report),

		// verify IAS signature over public key of QE
		Eq(true, verify(sign(pk(~priv_QE), ~priv_IAS), pk(~priv_QE), pk(~priv_IAS))),

		// verify QE signature over contents of quote
		Eq(true, verify(sign(content, ~priv_QE), content, pk(~priv_QE)))
	]->[
		Out(report)
	]






/******************************************************** */

restriction Equality:
	"All x y #i. Eq(x,y)@i ==> x=y"

// restriction Inequality:
// 	"All x #i. Neq(x,x) @i ==> F"

restriction OnlyOnce:
	"All #i #j. OnlyOnce() @#i & OnlyOnce() @#j ==> #i = #j"


// // E1 e E2 são o mesmo enclave mas a executar em processadores diferentes: E1 no CPU_1, e E2 e E3 no CPU_3.
// lemma setup: exists-trace
// 	"
// 	Ex
// 		E1 E2 E3
// 		MRENCLAVE_1 MRSIGNER_1 MRENCLAVE_3 MRSIGNER_3 tid_E1 tid_E2 tid_E3
// 		IAS
// 		CPU_1 CPU_3
// 		QE_1 tid_QE_1 tid_CPU_1
// 		QE_3 tid_QE_3 tid_CPU_3
// 		CAS tid_CAS tid_IAS
// 	#t11 #t12 #t13 #t21 #t22 #t23 #t31 #t32 #t33 #t41 #t42 #t51 #t52 #t61 #t62.
//
// 	Create_Enclave(E1, MRENCLAVE_1, MRSIGNER_1) @ #t11 & Licensing(E1, IAS) @ #t12 & Binding(tid_E1, E1, CPU_1) @ #t13 &
//
// 	Create_Enclave(E2, MRENCLAVE_1, MRSIGNER_1) @ #t21 & Licensing(E2, IAS) @ #t22 & Binding(tid_E2, E2, CPU_3) @ #t23 &
//
// 	Create_Enclave(E3, MRENCLAVE_3, MRSIGNER_3) @ #t31 & Licensing(E3, IAS) @ #t32 & Binding(tid_E3, E3, CPU_3) @ #t33 &
//
// 	Create_QE(QE_1) @ #t41 & Provision(QE_1, CPU_1, IAS, tid_QE_1, tid_CPU_1) @ #t42 &
//
// 	Create_QE(QE_3) @ #t51 & Provision(QE_3, CPU_3, IAS, tid_QE_3, tid_CPU_3) @ #t52 &
//
// 	Create_CAS(CAS) @ #t61 & Register_CAS(CAS, IAS, tid_CAS, tid_IAS) @ #t62 &
//
// 	t31 < t32 & t32 < t33
// 	"

// Provar caminho ...
lemma Frank: exists-trace
	"
	// Ex tid_Enclave tid_QE report quote tid_CAS tid_IAS tid_RA aep avr #t1 #t2 #t3 #t4 #t5 #t6 #t7.
	Ex
		id_IAS id_QE id_CPU id_Enclave MRENCLAVE MRSIGNER
		tid_CPU tid_QE
		tid_Enclave report quote reply
		F hF
	#s1 #s3 #s4 #s5 #s6 #s7 #s8
	#t1 #t2 #t3 #t5 #t7.

	not(id_IAS=id_QE) & not(id_IAS=id_CPU) & not(id_IAS=id_Enclave) & not(id_QE=id_CPU) & not(id_QE=id_Enclave) & not(id_CPU=id_Enclave) &

	not(report=quote) & not(report=reply) & not(quote=reply) &

	Create_IAS(id_IAS) @ s1 &
	// Create_CAS(id_CAS) @ s2 &
	Create_QE(id_QE) @ s3 &
	Create_CPU(id_CPU) @ s4 &
	Create_Enclave(id_Enclave, MRENCLAVE, MRSIGNER) @ s5 &

	Provision(id_QE, id_CPU, id_IAS, tid_QE, tid_CPU) @ s6 &
	Licensing(id_Enclave, id_IAS) @ s7 &
	Binding(tid_Enclave, id_Enclave, id_CPU) @ s8 &
	// Register_CAS(id_CAS, id_IAS, tid_CAS, tid_IAS) @ s9 &

	// s1 < t1 & s1 < t2 & s1 < t3 & s1 < t4 & s1 < t5 & s1 < t6 & s1 < t7 &

	Progress_F1(tid_Enclave, F, '1', hF, report) @ t1 &
	Progress_QE_new_1(tid_QE, tid_CPU, report, quote) @ t2 &
	Progress_F2(tid_Enclave, F, '1', '2', hF, quote) @ t3
	&
	// Progress_CAS_2(tid_CAS, tid_IAS, tid_RA, quote, aep) @ t4 &
	Progress_IAS(id_IAS, quote, reply) @ t5 &
	// Progress_CAS_3(tid_CAS, tid_IAS, tid_RA, avr) @ t6 &
	Progress_F3(tid_Enclave, F, '2', hF, reply) @ t7 &

	s8 < t1 & // binding antes de Frank 1

	s6 < t2 &

	t1 < t2 & t2 < t3 & t3 < t5 & t5 < t7

	// t1 < t5 & // partial deconstruction no IAS, ordem resolve? Nope!

	// (not (Ex #r. Reveal() @ r))
	"

end
