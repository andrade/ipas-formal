/**
** Protocol: AS v3
** Author:   Daniel Andrade
** Date:     10/2021
** Status:   Working
**/

theory ASv3_no_CAS
begin

builtins: hashing, signing

functions:
	CMAC/2,                  // RFC 4493
	real/1 [private],
	sgx_get_key/1

rule Create_IAS:
	[
		Fr(~id_IAS),
		Fr(~priv_IAS)
	]--[
		OnlyOnce(),
		Create_IAS(~id_IAS)
	]->[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS), // root keys, we use single key pair
		Out(~id_IAS)
	]

rule Create_QE:
	[ Fr(~id_QE) ]--[ Create_QE(~id_QE) ]->[ !ID_QE(~id_QE), Out(~id_QE) ]

rule Create_Enclave:
	[
		Fr(~id_Enclave),
		Fr(~MRENCLAVE),
		Fr(~MRSIGNER)
	]--[
		Create_Enclave(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]->[
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		Out(~id_Enclave),
		Out(~MRENCLAVE),
		Out(~MRSIGNER)
	]

rule Create_CPU:
	[
		Fr(~id_CPU)
	]--[
		Create_CPU(~id_CPU)
	]->[
		!ID_CPU(~id_CPU),
		Out(~id_CPU)
	]

// Provision CPU and QE: essentially registers these two agents with Intel
rule Provisioning:
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		!ID_QE(~id_QE),
		!ID_CPU(~id_CPU),
		Fr(~tid_QE),
		Fr(~priv_QE), // attestation key for QE, uses to sign quotes
		Fr(~tid_CPU)
	]--[
		Provision(~id_QE, ~id_CPU, ~id_IAS, ~tid_QE, ~tid_CPU)
	]->[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		State_CPU(~tid_CPU, 'Provisioning_CPU', <~id_CPU, ~tid_QE, ~id_QE, ~id_IAS, sign(~id_CPU, ~priv_IAS), pk(~priv_IAS)>)
	]

// Whitelist enclave
rule Licensing:
	let
		// Enclave ID, IAS ID, IAS signature over Enclave ID, IAS public key
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]--[
		Licensing(~id_Enclave, ~id_IAS)
	]->[
		!License(~id_Enclave, license)
	]

// Bind enclave to CPU
rule Binding:
	[
		!ID_CPU(~id_CPU),
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		Fr(~tid_Enclave)
	]--[
		Binding(~tid_Enclave, ~id_Enclave, ~id_CPU)
	]->[
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~id_CPU>)
	]

rule Frank_1:
	let
		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

		data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		so = <~hF>
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~id_CPU>),
		Fr(~hF)
	]--[
		Progress_F1(~tid_Enclave, $F, ~hF, report)
	]->[
		State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~id_CPU>),
		AgSt('enclave', $F, '1', so),
		Out(report)
	]

rule Frank_2:
	let
		si = <~hF>
		so = <~hF>

		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sig_IAS>
	in
	[
		AgSt('enclave', $F, '1', si),
		State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~id_CPU>),
		In(quote)
	]--[
		Progress_F2(~tid_Enclave, $F, ~hF, quote)
	]->[
		State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~id_CPU>),
		AgSt('enclave', $F, '2', so),
		Out(quote)
	]

rule Frank_3:
	let
		si = <~hF>

		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>

		data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		content = <body>
		report = <content, sign(content, ~priv_IAS)>
	in
	[
		AgSt('enclave', $F, '2', si),
		State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~id_CPU>),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		In(report)
	]--[
		Progress_F3(~tid_Enclave, $F, ~hF, report)
	]->[
	]

/**
** The Quoting Enclave receives a report from an enclave, and
** produces a certified (signed by AK) quote for that enclave.
**/
rule QE [color=AADADA]:
	let
		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>
		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
	in
	[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		In(report)
	]--[
		Progress_QE(~tid_QE, ~tid_CPU, report, quote)
	]->[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		Out(quote)
	]

rule IAS [color=DADADA]:
	let
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>

		report = <content, sign(content, ~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		In(quote)
	]--[
		Progress_IAS(~id_IAS, quote, report),

		// verify IAS signature over public key of QE
		Eq(true, verify(sign(pk(~priv_QE), ~priv_IAS), pk(~priv_QE), pk(~priv_IAS))),

		// verify QE signature over contents of quote
		Eq(true, verify(sign(content, ~priv_QE), content, pk(~priv_QE)))
	]->[
		Out(report)
	]



/******************************************************** */

restriction Equality:
	"All x y #i. Eq(x,y)@i ==> x=y"

restriction OnlyOnce:
	"All #i #j. OnlyOnce() @#i & OnlyOnce() @#j ==> #i = #j"


// // E1 e E2 s√£o o mesmo enclave mas a executar em processadores diferentes: E1 no CPU_1, e E2 e E3 no CPU_3.
// lemma setup: exists-trace
// 	"
// 	Ex
// 		E1 E2 E3
// 		MRENCLAVE_1 MRSIGNER_1 MRENCLAVE_3 MRSIGNER_3 tid_E1 tid_E2 tid_E3
// 		IAS
// 		CPU_1 CPU_3
// 		QE_1 tid_QE_1 tid_CPU_1
// 		QE_3 tid_QE_3 tid_CPU_3
// 		CAS tid_CAS tid_IAS
// 	#t11 #t12 #t13 #t21 #t22 #t23 #t31 #t32 #t33 #t41 #t42 #t51 #t52 #t61 #t62.
//
// 	Create_Enclave(E1, MRENCLAVE_1, MRSIGNER_1) @ #t11 & Licensing(E1, IAS) @ #t12 & Binding(tid_E1, E1, CPU_1) @ #t13 &
//
// 	Create_Enclave(E2, MRENCLAVE_1, MRSIGNER_1) @ #t21 & Licensing(E2, IAS) @ #t22 & Binding(tid_E2, E2, CPU_3) @ #t23 &
//
// 	Create_Enclave(E3, MRENCLAVE_3, MRSIGNER_3) @ #t31 & Licensing(E3, IAS) @ #t32 & Binding(tid_E3, E3, CPU_3) @ #t33 &
//
// 	Create_QE(QE_1) @ #t41 & Provision(QE_1, CPU_1, IAS, tid_QE_1, tid_CPU_1) @ #t42 &
//
// 	Create_QE(QE_3) @ #t51 & Provision(QE_3, CPU_3, IAS, tid_QE_3, tid_CPU_3) @ #t52 &
//
// 	Create_CAS(CAS) @ #t61 & Register_CAS(CAS, IAS, tid_CAS, tid_IAS) @ #t62 &
//
// 	t31 < t32 & t32 < t33
// 	"

// Provar caminho ...
lemma Frank: exists-trace
	"
	Ex
		id_IAS id_QE id_CPU id_Enclave MRENCLAVE MRSIGNER
		tid_CPU tid_QE
		tid_Enclave report quote reply
		F hF
	#s1 #s3 #s4 #s5 #s6 #s7 #s8
	#t1 #t2 #t3 #t5 #t7.

	not(id_IAS=id_QE) & not(id_IAS=id_CPU) & not(id_IAS=id_Enclave) & not(id_QE=id_CPU) & not(id_QE=id_Enclave) & not(id_CPU=id_Enclave) &

	not(report=quote) & not(report=reply) & not(quote=reply) &

	Create_IAS(id_IAS) @ s1 &
	Create_QE(id_QE) @ s3 &
	Create_CPU(id_CPU) @ s4 &
	Create_Enclave(id_Enclave, MRENCLAVE, MRSIGNER) @ s5 &

	Provision(id_QE, id_CPU, id_IAS, tid_QE, tid_CPU) @ s6 &
	Licensing(id_Enclave, id_IAS) @ s7 &
	Binding(tid_Enclave, id_Enclave, id_CPU) @ s8 &

	Progress_F1(tid_Enclave, F, hF, report) @ t1 &
	Progress_QE(tid_QE, tid_CPU, report, quote) @ t2 &
	Progress_F2(tid_Enclave, F, hF, quote) @ t3 &
	Progress_IAS(id_IAS, quote, reply) @ t5 &
	Progress_F3(tid_Enclave, F, hF, reply) @ t7 &

	s8 < t1 & // binding antes de Frank 1

	s6 < t2 & // provisioning antes de QE

	t1 < t2 & t2 < t3 & t3 < t5 & t5 < t7
	"

end
