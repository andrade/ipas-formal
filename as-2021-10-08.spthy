/**
** Protocol: AS v3
** Author:   Daniel Andrade
** Date:     10/2021
** Status:   Working
**/

theory ASv3_no_CAS
begin

builtins: hashing, signing

functions:
	CMAC/2,                  // RFC 4493
	real/1 [private],
	sgx_get_key/1

rule Create_IAS:
	[
		Fr(~id_IAS),
		Fr(~priv_IAS)
	]--[
		OnlyOnce(),
		Create_IAS(~id_IAS)
	]->[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS), // root keys, we use single key pair
		Out(~id_IAS)
	]

rule Create_QE:
	[ Fr(~id_QE) ]--[ Create_QE(~id_QE) ]->[ !ID_QE(~id_QE), Out(~id_QE) ]

rule Create_Enclave:
	[
		Fr(~id_Enclave),
		Fr(~MRENCLAVE),
		Fr(~MRSIGNER)
	]--[
		Create_Enclave(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]->[
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		Out(~id_Enclave),
		Out(~MRENCLAVE),
		Out(~MRSIGNER)
	]

rule Create_CPU:
	[
		Fr(~id_CPU)
	]--[
		Create_CPU(~id_CPU)
	]->[
		!ID_CPU(~id_CPU),
		Out(~id_CPU)
	]

// Provision CPU and QE: essentially registers these two agents with Intel
rule Provisioning:
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		!ID_QE(~id_QE),
		!ID_CPU(~id_CPU),
		Fr(~tid_QE),
		Fr(~priv_QE), // attestation key for QE, uses to sign quotes
		Fr(~tid_CPU)
	]--[
		Provision(~id_QE, ~id_CPU, ~id_IAS, ~tid_QE, ~tid_CPU)
	]->[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		State_CPU(~tid_CPU, 'Provisioning_CPU', <~id_CPU, ~tid_QE, ~id_QE, ~id_IAS, sign(~id_CPU, ~priv_IAS), pk(~priv_IAS)>)
	]

// Whitelist enclave
rule Licensing:
	let
		// Enclave ID, IAS ID, IAS signature over Enclave ID, IAS public key
		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pk(~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER)
	]--[
		Licensing(~id_Enclave, ~id_IAS)
	]->[
		!License(~id_Enclave, license)
	]

// Bind enclave to CPU
rule Binding:
	[
		!ID_CPU(~id_CPU),
		!ID_Enclave(~id_Enclave),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		Fr(~tid_Enclave)
	]--[
		Binding(~tid_Enclave, ~id_Enclave, ~id_CPU)
	]->[
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~id_CPU>)
	]

rule Frank_1:
	let
		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

		data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>

		so = <~hF>
	in
	[
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		State_Enclave(~tid_Enclave, 'bound', <~id_Enclave, ~id_CPU>),
		Fr(~hF)
	]--[
		Progress_F1(~tid_Enclave, $F, ~hF, report)
	]->[
		State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~id_CPU>),
		AgSt('enclave', $F, '1', so),
		Out(report)
	]

rule Frank_2:
	let
		si = <~hF>
		so = <~hF>

		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sig_IAS>
	in
	[
		AgSt('enclave', $F, '1', si),
		State_Enclave(~tid_Enclave, 'started', <~id_Enclave, ~id_CPU>),
		In(quote)
	]--[
		Progress_F2(~tid_Enclave, $F, ~hF, quote)
	]->[
		State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~id_CPU>),
		AgSt('enclave', $F, '2', so),
		Out(quote)
	]

rule Frank_3:
	let
		si = <~hF>

		license = <~id_Enclave, ~id_IAS, sign(~id_Enclave, ~priv_IAS), pub_IAS>

		data = <~hF>
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		content = <body>
		report = <content, signature>
	in
	[
		AgSt('enclave', $F, '2', si),
		State_Enclave(~tid_Enclave, 'attesting', <~id_Enclave, ~id_CPU>),
		!Measurements(~id_Enclave, ~MRENCLAVE, ~MRSIGNER),
		!License(~id_Enclave, license),
		In(report)
	]--[
		Progress_F3(~tid_Enclave, $F, ~hF, report),
		Eq(true, verify(signature, content, pub_IAS))
	]->[
	]

/**
** The Quoting Enclave receives a report from an enclave, and
** produces a certified (signed by AK) quote for that enclave.
**/
rule QE [color=AADADA]:
	let
		report_key = sgx_get_key(<~MRENCLAVE, 'report', real(~id_CPU)>)

		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		report = <body, CMAC(body, report_key)>
		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>
	in
	[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		In(report)
	]--[
		Progress_QE(~tid_QE, ~tid_CPU, report, quote)
	]->[
		State_QE(~tid_QE, 'idle', <~id_QE, ~tid_CPU, ~id_CPU, ~id_IAS, ~priv_QE, sign(pk(~priv_QE), ~priv_IAS), pk(~priv_IAS)>),
		Out(quote)
	]

rule IAS [color=DADADA]:
	let
		body = <$F, ~id_CPU, ~MRENCLAVE, data>
		content = <body>
		quote = <content, sign(content, ~priv_QE), pk(~priv_QE), sign(pk(~priv_QE), ~priv_IAS)>

		report = <content, sign(content, ~priv_IAS)>
	in
	[
		!ID_IAS(~id_IAS),
		!Keys_IAS(~id_IAS, ~priv_IAS),
		In(quote)
	]--[
		Progress_IAS(~id_IAS, quote, report),

		// verify IAS signature over public key of QE
		Eq(true, verify(sign(pk(~priv_QE), ~priv_IAS), pk(~priv_QE), pk(~priv_IAS))),

		// verify QE signature over contents of quote
		Eq(true, verify(sign(content, ~priv_QE), content, pk(~priv_QE)))
	]->[
		Out(report)
	]



/******************************************************** */

restriction Equality:
	"All x y #i. Eq(x,y)@i ==> x=y"

restriction OnlyOnce:
	"All #i #j. OnlyOnce() @#i & OnlyOnce() @#j ==> #i = #j"


// E1 e E2 s√£o o mesmo enclave mas a executar em processadores diferentes: E1 no CPU_1, e E2 e E3 no CPU_3.
lemma Multi: exists-trace
	"
	Ex
		id_CPU_1 tid_CPU_1 MRENCLAVE_1 MRSIGNER_1 id_QE_1 tid_QE_1
		id_CPU_3 tid_CPU_3 MRENCLAVE_3 MRSIGNER_3 id_QE_3 tid_QE_3
		E1 tid_E1 X h1 r1 q1 a1
		E2 tid_E2 Y h2 r2 q2 a2
		E3 tid_E3 Z h3 r3 q3 a3
		id_IAS
	#s11 #s12 #s13 #s14 #s15 #s16 #s17 #s18
	#s21 #s22 #s23 #s24 #s25 #s26 #s27 #s28
	#t1 #t2 #t3 #t4 #t5 #t6 #t7 #t8 #t9 #t10 #t11 #t12 #t13 #t14 #t15.

	not(id_CPU_1=id_CPU_3) &
	not(id_QE_1=id_QE_3) &
	E1=E2 & not(E2=E3) &
	not(tid_E1=tid_E2) &
	not(tid_E2=tid_E3) &
	not(MRENCLAVE_1=MRENCLAVE_3) &
	not(MRSIGNER_1=MRSIGNER_3) &

	Create_IAS(id_IAS) @ s11 &
	Create_QE(id_QE_1) @ s12 &
	Create_QE(id_QE_3) @ s13 &
	Create_CPU(id_CPU_1) @ s14 &
	Create_CPU(id_CPU_3) @ s15 &
	Create_Enclave(E1, MRENCLAVE_1, MRSIGNER_1) @ s16 &
	Create_Enclave(E2, MRENCLAVE_1, MRSIGNER_1) @ s17 &
	Create_Enclave(E3, MRENCLAVE_3, MRSIGNER_3) @ s18 &

	Provision(id_QE_1, id_CPU_1, id_IAS, tid_QE_1, tid_CPU_1) @ s21 &
	Provision(id_QE_3, id_CPU_3, id_IAS, tid_QE_3, tid_CPU_3) @ s22 &
	Licensing(E1, id_IAS) @ s23 &
	Licensing(E2, id_IAS) @ s24 &
	Licensing(E3, id_IAS) @ s25 &
	Binding(tid_E1, E1, id_CPU_1) @ s26 &
	Binding(tid_E2, E2, id_CPU_3) @ s27 &
	Binding(tid_E3, E3, id_CPU_3) @ s28 &

	Progress_F1(tid_E1, X, h1, r1) @ t1 &
	Progress_F1(tid_E2, Y, h2, r2) @ t2 &
	Progress_F1(tid_E3, Z, h3, r3) @ t3 &
	Progress_QE(tid_QE_1, tid_CPU_1, r1, q1) @ t4 &
	Progress_QE(tid_QE_3, tid_CPU_3, r2, q2) @ t5 &
	Progress_QE(tid_QE_3, tid_CPU_3, r3, q3) @ t6 &
	Progress_F2(tid_E1, X, h1, q1) @ t7 &
	Progress_F2(tid_E2, Y, h2, q2) @ t8 &
	Progress_F2(tid_E3, Z, h3, q3) @ t9 &
	Progress_IAS(id_IAS, q1, a1) @ t10 &
	Progress_IAS(id_IAS, q2, a2) @ t11 &
	Progress_IAS(id_IAS, q3, a3) @ t12 &
	Progress_F3(tid_E1, X, h1, a1) @ t13 &
	Progress_F3(tid_E2, Y, h2, a2) @ t14 &
	Progress_F3(tid_E3, Z, h3, a3) @ t15
	"

lemma Frank: exists-trace
	"
	Ex
		id_IAS id_QE id_CPU id_Enclave MRENCLAVE MRSIGNER
		tid_CPU tid_QE
		tid_Enclave report quote reply
		F hF
	#s1 #s3 #s4 #s5 #s6 #s7 #s8
	#t1 #t2 #t3 #t5 #t7.

	not(id_IAS=id_QE) & not(id_IAS=id_CPU) & not(id_IAS=id_Enclave) & not(id_QE=id_CPU) & not(id_QE=id_Enclave) & not(id_CPU=id_Enclave) &

	not(report=quote) & not(report=reply) & not(quote=reply) &

	Create_IAS(id_IAS) @ s1 &
	Create_QE(id_QE) @ s3 &
	Create_CPU(id_CPU) @ s4 &
	Create_Enclave(id_Enclave, MRENCLAVE, MRSIGNER) @ s5 &

	Provision(id_QE, id_CPU, id_IAS, tid_QE, tid_CPU) @ s6 &
	Licensing(id_Enclave, id_IAS) @ s7 &
	Binding(tid_Enclave, id_Enclave, id_CPU) @ s8 &

	Progress_F1(tid_Enclave, F, hF, report) @ t1 &
	Progress_QE(tid_QE, tid_CPU, report, quote) @ t2 &
	Progress_F2(tid_Enclave, F, hF, quote) @ t3 &
	Progress_IAS(id_IAS, quote, reply) @ t5 &
	Progress_F3(tid_Enclave, F, hF, reply) @ t7 &

	s8 < t1 & // binding antes de Frank 1

	s6 < t2 & // provisioning antes de QE

	t1 < t2 & t2 < t3 & t3 < t5 & t5 < t7
	"

end
